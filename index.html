<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>AI Text Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="console.log('OpenCV.js loaded');"></script>
    <style>
          body { margin: 0; }
          .animate-spin { animation: spin 1s linear infinite; }
          @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        </style>
  </head>
  <body>
      <div id="root"></div>
    <script type="text/babel">
            const { useState, useRef, useEffect } = React;

            function TextEditorPrototype() {
                    const [imageSrc, setImageSrc] = useState(null);
                    const [selectionMode, setSelectionMode] = useState('rectangle');
                    const [rectangleSelection, setRectangleSelection] = useState(null);
                    const [polygonPoints, setPolygonPoints] = useState([]);
                    const [isPolygonClosed, setIsPolygonClosed] = useState(false);
                    const [isSelecting, setIsSelecting] = useState(false);
                    const [startPos, setStartPos] = useState(null);
                    const [replacementText, setReplacementText] = useState('');
                    const [isGenerating, setIsGenerating] = useState(false);
                    const [isAnalyzing, setIsAnalyzing] = useState(false);
                    const [generatedOverlay, setGeneratedOverlay] = useState(null);
                    const [showConfirmation, setShowConfirmation] = useState(false);
                    const [pendingOverlay, setPendingOverlay] = useState(null);
                    const [tightBounds, setTightBounds] = useState(null);
                    const [styleSettings, setStyleSettings] = useState({
                              fontFamily: 'Arial',
                              fontSize: 24,
                              fontWeight: 'normal',
                              color: '#000000',
                              backgroundColor: '#ffffff',
                              letterSpacing: 0,
                              rotation: 0,
                              skew: 0,
                    });
                    const [detectedStyle, setDetectedStyle] = useState(null);
                    const [documentContext, setDocumentContext] = useState(null);
                    const [fontSuggestions, setFontSuggestions] = useState([]);
                    const [step, setStep] = useState('upload');
                    const [history, setHistory] = useState([]);
                    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
                    const [isDragging, setIsDragging] = useState(false);
                    const [detectedText, setDetectedText] = useState('');
                    const [ocrProgress, setOcrProgress] = useState(0);
                    const [qualityChecks, setQualityChecks] = useState(null);
                    const [ocrConfidence, setOcrConfidence] = useState(0);
                    const [openCVReady, setOpenCVReady] = useState(false);

                    const canvasRef = useRef(null);
                    const fileInputRef = useRef(null);
                    const imageObjRef = useRef(null);
                    const dragStartTime = useRef(0);
                    const dragStartPos = useRef(null);

                    // Check if OpenCV is loaded
                    useEffect(() => {
                              const checkOpenCV = setInterval(() => {
                                          if (typeof cv !== 'undefined' && cv.Mat) {
                                                        setOpenCVReady(true);
                                                        console.log('OpenCV.js is ready!');
                                                        clearInterval(checkOpenCV);
                                          }
                              }, 100);

                              // Clear interval after 30 seconds
                              setTimeout(() => clearInterval(checkOpenCV), 30000);

                              return () => clearInterval(checkOpenCV);
                    }, []);

                    const handleFileChange = (event) => {
                              const file = event.target.files?.[0];
                              if (!file) return;
                              if (!file.type.startsWith('image/')) { alert('Please select an image file'); return; }
                              const reader = new FileReader();
                              reader.onload = (e) => { const dataUrl = e.target?.result; if (typeof dataUrl === 'string') loadImage(dataUrl); };
                              reader.readAsDataURL(file);
                    };

                    const loadImage = (src) => {
                              const img = new Image();
                              img.onload = () => {
                                          imageObjRef.current = img; setImageSrc(src); resetSelection(); setHistory([]); setStep('select');
                                          requestAnimationFrame(() => { drawCanvas(); analyzeDocumentContext(); });
                              };
                              img.src = src;
                    };

                    const analyzeDocumentContext = () => {
                              const canvas = canvasRef.current; const img = imageObjRef.current;
                              if (!canvas || !img) return;
                              const ctx = canvas.getContext('2d');
                              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                              setDocumentContext({
                                          dominantColors: extractDominantColors(imageData),
                                          textDensity: estimateTextDensity(imageData),
                                          documentType: classifyDocument(imageData, canvas.width, canvas.height),
                                          estimatedDPI: estimateDPI(canvas.width, canvas.height),
                              });
                    };

                    const extractDominantColors = (imageData) => {
                              const data = imageData.data; const colorMap = {};
                              for (let i = 0; i < data.length; i += 40) {
                                          const r = Math.round(data[i] / 32) * 32, g = Math.round(data[i + 1] / 32) * 32, b = Math.round(data[i + 2] / 32) * 32;
                                          const key = r + ',' + g + ',' + b; colorMap[key] = (colorMap[key] || 0) + 1;
                              }
                              return Object.entries(colorMap).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([color]) => {
                                          const [r, g, b] = color.split(',').map(Number); return { r, g, b };
                              });
                    };

                    const estimateTextDensity = (imageData) => {
                              const data = imageData.data; let darkPixels = 0; const total = data.length / 4;
                              for (let i = 0; i < data.length; i += 4) {
                                          if (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2] < 128) darkPixels++;
                              }
                              return darkPixels / total;
                    };

                    const classifyDocument = (imageData, width, height) => {
                              const aspectRatio = width / height; const density = estimateTextDensity(imageData);
                              if (aspectRatio > 1.3 && aspectRatio < 1.5) return 'letter';
                              if (aspectRatio > 0.65 && aspectRatio < 0.8) return 'portrait';
                              if (density < 0.1) return 'sparse'; if (density > 0.3) return 'dense';
                              return 'standard';
                    };

                    const estimateDPI = (width, height) => {
                              const possibleDPI = Math.round(width / 8.5);
                              if (possibleDPI >= 70 && possibleDPI <= 100) return 72;
                              if (possibleDPI >= 140 && possibleDPI <= 160) return 150;
                              if (possibleDPI >= 280 && possibleDPI <= 320) return 300;
                              return possibleDPI;
                    };

                    const resetSelection = () => {
                              setRectangleSelection(null); setPolygonPoints([]); setIsPolygonClosed(false);
                              setGeneratedOverlay(null); setDetectedStyle(null); setFontSuggestions([]);
                              setTightBounds(null); setShowConfirmation(false); setPendingOverlay(null);
                              setDetectedText(''); setOcrProgress(0); setQualityChecks(null); setOcrConfidence(0);
                   };

                    const drawCanvas = () => {
                              const canvas = canvasRef.current;
                              const img = imageObjRef.current;
                              if (!canvas || !img) return;
                              const ctx = canvas.getContext('2d');
                              canvas.width = img.naturalWidth;
                              canvas.height = img.naturalHeight;
                              ctx.clearRect(0, 0, canvas.width, canvas.height);
                              ctx.drawImage(img, 0, 0);
                              history.forEach(overlay => drawTextOverlay(ctx, overlay));
                              if (generatedOverlay) drawTextOverlay(ctx, generatedOverlay);
                              if (showConfirmation && tightBounds) drawTightBoundsHighlight(ctx, tightBounds);
                              if (rectangleSelection && selectionMode === 'rectangle' && !showConfirmation) {
                                          drawRectangleSelection(ctx, rectangleSelection);
                              }
                              if (polygonPoints.length > 0 && !showConfirmation) drawPolygonSelection(ctx);
                    };

                    const drawTightBoundsHighlight = (ctx, bounds) => {
                              ctx.save();
                              const { x, y, width, height, rotation, skew } = bounds;
                              const centerX = x + width / 2;
                              const centerY = y + height / 2;
                              ctx.translate(centerX, centerY);
                              ctx.rotate((rotation || 0) * Math.PI / 180);
                              if (skew) ctx.transform(1, 0, Math.tan(skew * Math.PI / 180), 1, 0, 0);
                              ctx.translate(-width / 2, -height / 2);
                              ctx.strokeStyle = '#ef4444';
                              ctx.lineWidth = 4;
                              ctx.setLineDash([]);
                              ctx.strokeRect(-6, -6, width + 12, height + 12);
                              ctx.fillStyle = 'rgba(239, 68, 68, 0.25)';
                              ctx.fillRect(-6, -6, width + 12, height + 12);
                              const markerSize = 10;
                              ctx.fillStyle = '#ef4444';
                              [[-6, -6], [width + 6 - markerSize, -6], [-6, height + 6 - markerSize], [width + 6 - markerSize, height + 6 - markerSize]]
                                          .forEach(([mx, my]) => ctx.fillRect(mx, my, markerSize, markerSize));
                              ctx.restore();
                    };

                    const drawRectangleSelection = (ctx, sel) => {
                              ctx.save();
                              ctx.strokeStyle = '#3b82f6';
                              ctx.lineWidth = 3;
                              ctx.setLineDash([8, 4]);
                              ctx.strokeRect(sel.x, sel.y, sel.width, sel.height);
                              ctx.setLineDash([]);
                              ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                              ctx.fillRect(sel.x, sel.y, sel.width, sel.height);
                              const handleSize = 12;
                              ctx.fillStyle = '#3b82f6';
                              [[sel.x, sel.y], [sel.x + sel.width, sel.y], [sel.x, sel.y + sel.height], [sel.x + sel.width, sel.y + sel.height]]
                                          .forEach(([cx, cy]) => ctx.fillRect(cx - handleSize/2, cy - handleSize/2, handleSize, handleSize));
                              ctx.restore();
                    };

                    const drawPolygonSelection = (ctx) => {
                              ctx.save();
                              if (isPolygonClosed && polygonPoints.length >= 3) {
                                          ctx.beginPath();
                                          ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                                          polygonPoints.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                                          ctx.closePath();
                                          ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                                          ctx.fill();
                              }
                              ctx.strokeStyle = '#3b82f6';
                              ctx.lineWidth = 2;
                              ctx.setLineDash([]);
                              if (polygonPoints.length > 1) {
                                          ctx.beginPath();
                                          ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                                          polygonPoints.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                                          if (isPolygonClosed) ctx.closePath();
                                          ctx.stroke();
                              }
                              if (!isPolygonClosed && polygonPoints.length > 0 && step === 'select') {
                                          ctx.setLineDash([4, 4]);
                                          ctx.beginPath();
                                          ctx.moveTo(polygonPoints[polygonPoints.length - 1].x, polygonPoints[polygonPoints.length - 1].y);
                                          ctx.lineTo(mousePos.x, mousePos.y);
                                          ctx.stroke();
                              }
                              polygonPoints.forEach((point, idx) => {
                                          ctx.beginPath();
                                          const isFirstPoint = idx === 0;
                                          const radius = isFirstPoint ? 10 : 7;
                                          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                                          ctx.fillStyle = isFirstPoint ? '#22c55e' : '#3b82f6';
                                          ctx.fill();
                                          ctx.strokeStyle = '#fff';
                                          ctx.lineWidth = 2;
                                          ctx.setLineDash([]);
                                          ctx.stroke();
                                          ctx.fillStyle = '#fff';
                                          ctx.font = 'bold 10px Arial';
                                          ctx.textAlign = 'center';
                                          ctx.textBaseline = 'middle';
                                          ctx.fillText(String(idx + 1), point.x, point.y);
                              });
                              ctx.restore();
                    };

                    useEffect(() => {
                              if (imageSrc) drawCanvas();
                    }, [imageSrc, rectangleSelection, polygonPoints, isPolygonClosed, generatedOverlay, history, mousePos, showConfirmation, tightBounds]);

                    const drawTextOverlay = (ctx, overlay) => {
                              const { x, y, width, height, text, style, polygon } = overlay;
                              ctx.save();
                              if (polygon && polygon.length >= 3) {
                                          const bounds = getPolygonBounds(polygon);
                                          const centerX = bounds.x + bounds.width / 2;
                                          const centerY = bounds.y + bounds.height / 2;
                                          ctx.translate(centerX, centerY);
                                          ctx.rotate((style.rotation || 0) * Math.PI / 180);
                                          if (style.skew) ctx.transform(1, 0, Math.tan(style.skew * Math.PI / 180), 1, 0, 0);
                                          ctx.translate(-bounds.width / 2, -bounds.height / 2);
                                          ctx.beginPath();
                                          const offsetPolygon = polygon.map(p => ({ x: p.x - bounds.x, y: p.y - bounds.y }));
                                          ctx.moveTo(offsetPolygon[0].x, offsetPolygon[0].y);
                                          offsetPolygon.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                                          ctx.closePath();
                                          ctx.clip();
                                          ctx.fillStyle = style.backgroundColor;
                                          ctx.fillRect(0, 0, bounds.width, bounds.height);
                                          drawTextInBounds(ctx, text, style, bounds.width, bounds.height);
                              } else {
                                          const centerX = x + width / 2;
                                          const centerY = y + height / 2;
                                          ctx.translate(centerX, centerY);
                                          ctx.rotate((style.rotation || 0) * Math.PI / 180);
                                          if (style.skew) ctx.transform(1, 0, Math.tan(style.skew * Math.PI / 180), 1, 0, 0);
                                          ctx.translate(-width / 2, -height / 2);
                                          ctx.fillStyle = style.backgroundColor;
                                          ctx.fillRect(0, 0, width, height);
                                          drawTextInBounds(ctx, text, style, width, height);
                              }
                              ctx.restore();
                    };

                    const drawTextInBounds = (ctx, text, style, width, height) => {
                              ctx.fillStyle = style.color;
                              ctx.font = style.fontWeight + ' ' + style.fontSize + 'px ' + style.fontFamily;
                              ctx.textBaseline = 'middle';
                              const words = text.split(' ');
                              const lineHeight = style.fontSize * 1.2;
                              let line = '';
                              let currentY = lineHeight / 2 + 4;
                              const padding = 4;
                              words.forEach((word, i) => {
                                          const testLine = line + word + ' ';
                                          const metrics = ctx.measureText(testLine);
                                          if (metrics.width > width - padding * 2 && i > 0) {
                                                        ctx.fillText(line.trim(), padding, currentY);
                                                        line = word + ' ';
                                                        currentY += lineHeight;
                                          } else {
                                                        line = testLine;
                                          }
                              });
                              ctx.fillText(line.trim(), padding, currentY);
                    };

                    const getPolygonBounds = (points) => {
                              const xs = points.map(p => p.x);
                              const ys = points.map(p => p.y);
                              const minX = Math.min(...xs);
                              const maxX = Math.max(...xs);
                              const minY = Math.min(...ys);
                              const maxY = Math.max(...ys);
                              return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                    };

                    const getCanvasCoords = (e) => {
                              const canvas = canvasRef.current;
                              if (!canvas) return { x: 0, y: 0 };
                              const rect = canvas.getBoundingClientRect();
                              const scaleX = canvas.width / rect.width;
                              const scaleY = canvas.height / rect.height;
                              return {
                                          x: (e.clientX - rect.left) * scaleX,
                                          y: (e.clientY - rect.top) * scaleY,
                              };
                    };

                    const isNearFirstPoint = (pos) => {
                              if (polygonPoints.length < 3) return false;
                              const first = polygonPoints[0];
                              const dist = Math.sqrt(Math.pow(pos.x - first.x, 2) + Math.pow(pos.y - first.y, 2));
                              return dist < 20;
                    };

                    const handleMouseDown = (e) => {
                              if (step !== 'select' || !imageSrc || showConfirmation) return;
                              const pos = getCanvasCoords(e);
                              dragStartTime.current = Date.now();
                              dragStartPos.current = pos;
                              setIsDragging(true);
                              if (selectionMode === 'rectangle') {
                                          setIsSelecting(true);
                                          setStartPos(pos);
                                          setRectangleSelection(null);
                                          setPolygonPoints([]);
                                          setIsPolygonClosed(false);
                              }
                    };

                    const handleMouseMove = (e) => {
                              const pos = getCanvasCoords(e);
                              setMousePos(pos);
                              if (!isDragging || !dragStartPos.current) return;
                              const dist = Math.sqrt(
                                          Math.pow(pos.x - dragStartPos.current.x, 2) +
                                          Math.pow(pos.y - dragStartPos.current.y, 2)
                                        );
                              if (dist > 5 && selectionMode === 'rectangle' && isSelecting) {
                                          setRectangleSelection({
                                                        x: Math.min(startPos.x, pos.x),
                                                        y: Math.min(startPos.y, pos.y),
                                                        width: Math.abs(pos.x - startPos.x),
                                                        height: Math.abs(pos.y - startPos.y),
                                          });
                              }
                    };

                    const handleMouseUp = async (e) => {
                              const pos = getCanvasCoords(e);
                              const timeDiff = Date.now() - dragStartTime.current;
                              const dist = dragStartPos.current ? Math.sqrt(
                                          Math.pow(pos.x - dragStartPos.current.x, 2) +
                                          Math.pow(pos.y - dragStartPos.current.y, 2)
                                        ) : 0;
                              setIsDragging(false);
                              const isClick = timeDiff < 300 && dist < 10;
                              if (isClick && step === 'select') {
                                          if (isPolygonClosed) {
                                                        setPolygonPoints([pos]);
                                                        setIsPolygonClosed(false);
                                                        setRectangleSelection(null);
                                                        setSelectionMode('polygon');
                                          } else if (isNearFirstPoint(pos) && polygonPoints.length >= 3) {
                                                        setIsPolygonClosed(true);
                                                        setStep('edit');
                                                        await analyzeSelection();
                                          } else {
                                                        setPolygonPoints(prev => [...prev, pos]);
                                                        setRectangleSelection(null);
                                                        setSelectionMode('polygon');
                                          }
                              } else if (!isClick && selectionMode === 'rectangle') {
                                          setIsSelecting(false);
                                          setStartPos(null);
                                          if (rectangleSelection && rectangleSelection.width > 20 && rectangleSelection.height > 20) {
                                                        setPolygonPoints([]);
                                                        setIsPolygonClosed(false);
                                                        setStep('edit');
                                                        await analyzeSelection();
                                          }
                              }
                    };

                    // AI-powered quality control checks
                    const performQualityChecks = (imageData, detectedStyle, ocrResult) => {
                              const checks = {
                                          blur: detectBlur(imageData),
                                          contrast: checkContrast(detectedStyle.color, detectedStyle.backgroundColor),
                                          readability: assessReadability(detectedStyle),
                                          accessibility: checkWCAGCompliance(detectedStyle.color, detectedStyle.backgroundColor),
                                          ocrConfidence: ocrResult.confidence || 0,
                                          resolution: assessResolution(imageData),
                                          warnings: [],
                                          suggestions: []
                              };

                              // Generate warnings and suggestions
                              if (checks.blur.isBlurry) {
                                          checks.warnings.push({
                                                        type: 'blur',
                                                        severity: 'high',
                                                        message: 'Image appears blurry (variance: ' + checks.blur.variance.toFixed(2) + ')',
                                                        icon: '‚ö†Ô∏è'
                                          });
                                          checks.suggestions.push('Try selecting a clearer area or use a higher resolution image');
                              }

                              if (checks.contrast.ratio < 4.5) {
                                          checks.warnings.push({
                                                        type: 'contrast',
                                                        severity: 'medium',
                                                        message: 'Low contrast ratio: ' + checks.contrast.ratio.toFixed(2) + ':1',
                                                        icon: '‚ö†Ô∏è'
                                          });
                                          checks.suggestions.push('Increase contrast between text and background for better readability');
                              }

                              if (!checks.accessibility.passesAA) {
                                          checks.warnings.push({
                                                        type: 'accessibility',
                                                        severity: 'medium',
                                                        message: 'Does not meet WCAG AA standards',
                                                        icon: '‚ôø'
                                          });
                                          checks.suggestions.push('Adjust colors to meet accessibility guidelines');
                              }

                              if (checks.ocrConfidence < 70) {
                                          checks.warnings.push({
                                                        type: 'ocr',
                                                        severity: checks.ocrConfidence < 40 ? 'high' : 'medium',
                                                        message: 'Low OCR confidence: ' + checks.ocrConfidence.toFixed(1) + '%',
                                                        icon: 'üîç'
                                          });
                                          checks.suggestions.push('Manually verify the detected text for accuracy');
                              }

                              if (checks.resolution.quality === 'low') {
                                          checks.warnings.push({
                                                        type: 'resolution',
                                                        severity: 'low',
                                                        message: 'Low resolution selection',
                                                        icon: '‚ÑπÔ∏è'
                                          });
                                          checks.suggestions.push('Select a larger area or use a higher quality image');
                              }

                              return checks;
                    };

                    const detectBlur = (imageData) => {
                              const data = imageData.data;
                              const width = imageData.width;
                              const height = imageData.height;

                              // Calculate Laplacian variance for blur detection
                              let variance = 0;
                              let count = 0;

                              for (let y = 1; y < height - 1; y++) {
                                          for (let x = 1; x < width - 1; x++) {
                                                        const idx = (y * width + x) * 4;
                                                        const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];

                                                        // Laplacian kernel
                                                        const top = 0.299 * data[((y - 1) * width + x) * 4] + 0.587 * data[((y - 1) * width + x) * 4 + 1] + 0.114 * data[((y - 1) * width + x) * 4 + 2];
                                                        const bottom = 0.299 * data[((y + 1) * width + x) * 4] + 0.587 * data[((y + 1) * width + x) * 4 + 1] + 0.114 * data[((y + 1) * width + x) * 4 + 2];
                                                        const left = 0.299 * data[(y * width + x - 1) * 4] + 0.587 * data[(y * width + x - 1) * 4 + 1] + 0.114 * data[(y * width + x - 1) * 4 + 2];
                                                        const right = 0.299 * data[(y * width + x + 1) * 4] + 0.587 * data[(y * width + x + 1) * 4 + 1] + 0.114 * data[(y * width + x + 1) * 4 + 2];

                                                        const laplacian = Math.abs(4 * gray - top - bottom - left - right);
                                                        variance += laplacian * laplacian;
                                                        count++;
                                          }
                              }

                              variance = Math.sqrt(variance / count);
                              const threshold = 15; // Lower = more blurry

                              return {
                                          variance: variance,
                                          isBlurry: variance < threshold,
                                          quality: variance > 30 ? 'sharp' : variance > 15 ? 'acceptable' : 'blurry'
                              };
                    };

                    const checkContrast = (textColor, bgColor) => {
                              const getLuminance = (hex) => {
                                          const r = parseInt(hex.slice(1, 3), 16) / 255;
                                          const g = parseInt(hex.slice(3, 5), 16) / 255;
                                          const b = parseInt(hex.slice(5, 7), 16) / 255;

                                          const rsRGB = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
                                          const gsRGB = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
                                          const bsRGB = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

                                          return 0.2126 * rsRGB + 0.7152 * gsRGB + 0.0722 * bsRGB;
                              };

                              const lum1 = getLuminance(textColor);
                              const lum2 = getLuminance(bgColor);
                              const ratio = (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);

                              return {
                                          ratio: ratio,
                                          rating: ratio >= 7 ? 'AAA' : ratio >= 4.5 ? 'AA' : ratio >= 3 ? 'AA Large' : 'Fail'
                              };
                    };

                    const checkWCAGCompliance = (textColor, bgColor) => {
                              const contrast = checkContrast(textColor, bgColor);
                              return {
                                          passesAA: contrast.ratio >= 4.5,
                                          passesAAA: contrast.ratio >= 7,
                                          passesAALarge: contrast.ratio >= 3,
                                          ratio: contrast.ratio
                              };
                    };

                    const assessReadability = (style) => {
                              let score = 100;
                              const issues = [];

                              // Check font size
                              if (style.fontSize < 12) {
                                          score -= 30;
                                          issues.push('Font size too small');
                              } else if (style.fontSize < 16) {
                                          score -= 10;
                                          issues.push('Font size below recommended');
                              }

                              // Check rotation
                              if (Math.abs(style.rotation) > 10) {
                                          score -= 20;
                                          issues.push('Significant text rotation detected');
                              }

                              // Check skew
                              if (Math.abs(style.skew) > 5) {
                                          score -= 15;
                                          issues.push('Text appears skewed');
                              }

                              return {
                                          score: Math.max(0, score),
                                          grade: score >= 80 ? 'Excellent' : score >= 60 ? 'Good' : score >= 40 ? 'Fair' : 'Poor',
                                          issues: issues
                              };
                    };

                    const assessResolution = (imageData) => {
                              const pixelCount = imageData.width * imageData.height;
                              const quality = pixelCount > 40000 ? 'high' : pixelCount > 10000 ? 'medium' : 'low';

                              return {
                                          width: imageData.width,
                                          height: imageData.height,
                                          pixels: pixelCount,
                                          quality: quality,
                                          dpi: Math.round((imageData.width + imageData.height) / 2 / 2.5) // rough estimate
                              };
                    };

                    // Advanced image preprocessing with OpenCV
                    const preprocessImageForOCR = (imageData) => {
                              if (typeof cv === 'undefined') {
                                          console.warn('OpenCV not loaded yet, using original image');
                                          return imageData;
                              }

                              try {
                                          // Create OpenCV Mat from imageData
                                          const src = cv.matFromImageData(imageData);
                                          const gray = new cv.Mat();
                                          const blurred = new cv.Mat();
                                          const thresh = new cv.Mat();

                                          // Convert to grayscale
                                          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                                          // Apply Gaussian blur to reduce noise
                                          cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);

                                          // Apply adaptive thresholding for better text extraction
                                          cv.adaptiveThreshold(
                                                        blurred,
                                                        thresh,
                                                        255,
                                                        cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                                                        cv.THRESH_BINARY,
                                                        11,
                                                        2
                                          );

                                          // Optional: Apply morphological operations to clean up
                                          const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                                          const morph = new cv.Mat();
                                          cv.morphologyEx(thresh, morph, cv.MORPH_CLOSE, kernel);

                                          // Convert back to RGBA for canvas
                                          const rgba = new cv.Mat();
                                          cv.cvtColor(morph, rgba, cv.COLOR_GRAY2RGBA);

                                          // Create new imageData from processed image
                                          const processed = new ImageData(
                                                        new Uint8ClampedArray(rgba.data),
                                                        rgba.cols,
                                                        rgba.rows
                                          );

                                          // Clean up
                                          src.delete();
                                          gray.delete();
                                          blurred.delete();
                                          thresh.delete();
                                          kernel.delete();
                                          morph.delete();
                                          rgba.delete();

                                          return processed;
                              } catch (error) {
                                          console.error('OpenCV preprocessing error:', error);
                                          return imageData;
                              }
                    };

                    // Advanced text angle detection using Hough Transform
                    const detectTextAngleOpenCV = (imageData) => {
                              if (typeof cv === 'undefined') {
                                          return detectTextAngle(imageData, null); // Fallback to original method
                              }

                              try {
                                          const src = cv.matFromImageData(imageData);
                                          const gray = new cv.Mat();
                                          const edges = new cv.Mat();
                                          const lines = new cv.Mat();

                                          // Convert to grayscale
                                          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                                          // Detect edges using Canny
                                          cv.Canny(gray, edges, 50, 150, 3);

                                          // Detect lines using Hough Transform
                                          cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 50, 50, 10);

                                          // Calculate angles from detected lines
                                          const angles = [];
                                          for (let i = 0; i < lines.rows; i++) {
                                                        const startX = lines.data32S[i * 4];
                                                        const startY = lines.data32S[i * 4 + 1];
                                                        const endX = lines.data32S[i * 4 + 2];
                                                        const endY = lines.data32S[i * 4 + 3];

                                                        const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);

                                                        // Normalize angle to -90 to 90
                                                        let normalizedAngle = angle;
                                                        if (normalizedAngle > 90) normalizedAngle -= 180;
                                                        if (normalizedAngle < -90) normalizedAngle += 180;

                                                        // Filter out near-vertical lines (they're probably not text baseline)
                                                        if (Math.abs(normalizedAngle) < 45) {
                                                                      angles.push(normalizedAngle);
                                                        }
                                          }

                                          // Clean up
                                          src.delete();
                                          gray.delete();
                                          edges.delete();
                                          lines.delete();

                                          if (angles.length === 0) {
                                                        return 0;
                                          }

                                          // Find median angle
                                          angles.sort((a, b) => a - b);
                                          const medianAngle = angles[Math.floor(angles.length / 2)];

                                          return medianAngle;
                              } catch (error) {
                                          console.error('OpenCV angle detection error:', error);
                                          return detectTextAngle(imageData, null); // Fallback
                              }
                    };

                    // Auto-deskew image
                    const deskewImage = (imageData, angle) => {
                              if (typeof cv === 'undefined' || Math.abs(angle) < 0.5) {
                                          return imageData;
                              }

                              try {
                                          const src = cv.matFromImageData(imageData);
                                          const dst = new cv.Mat();

                                          // Calculate rotation matrix
                                          const center = new cv.Point(src.cols / 2, src.rows / 2);
                                          const rotationMatrix = cv.getRotationMatrix2D(center, -angle, 1.0);

                                          // Calculate new dimensions to avoid cropping
                                          const cos = Math.abs(rotationMatrix.doubleAt(0, 0));
                                          const sin = Math.abs(rotationMatrix.doubleAt(0, 1));
                                          const newWidth = Math.floor(src.rows * sin + src.cols * cos);
                                          const newHeight = Math.floor(src.rows * cos + src.cols * sin);

                                          // Adjust rotation matrix for new center
                                          rotationMatrix.doublePtr(0, 2)[0] += (newWidth / 2) - center.x;
                                          rotationMatrix.doublePtr(1, 2)[0] += (newHeight / 2) - center.y;

                                          // Perform rotation
                                          const dsize = new cv.Size(newWidth, newHeight);
                                          cv.warpAffine(
                                                        src,
                                                        dst,
                                                        rotationMatrix,
                                                        dsize,
                                                        cv.INTER_CUBIC,
                                                        cv.BORDER_CONSTANT,
                                                        new cv.Scalar(255, 255, 255, 255)
                                          );

                                          // Convert back to imageData
                                          const deskewed = new ImageData(
                                                        new Uint8ClampedArray(dst.data),
                                                        dst.cols,
                                                        dst.rows
                                          );

                                          // Clean up
                                          src.delete();
                                          dst.delete();
                                          rotationMatrix.delete();

                                          return deskewed;
                              } catch (error) {
                                          console.error('Deskew error:', error);
                                          return imageData;
                              }
                    };

                    const analyzeSelection = async () => {
                              setIsAnalyzing(true);
                              setOcrProgress(0);
                              const canvas = canvasRef.current;
                              const ctx = canvas.getContext('2d');
                              let bounds;
                              let selectionMask = null;
                              if (isPolygonClosed && polygonPoints.length >= 3) {
                                          bounds = getPolygonBounds(polygonPoints);
                                          selectionMask = createPolygonMask(polygonPoints, bounds);
                              } else if (rectangleSelection) {
                                          bounds = rectangleSelection;
                              } else {
                                          setIsAnalyzing(false);
                                          return;
                              }
                              try {
                                          let imageData = ctx.getImageData(
                                                        Math.max(0, Math.floor(bounds.x)),
                                                        Math.max(0, Math.floor(bounds.y)),
                                                        Math.min(Math.floor(bounds.width), canvas.width - Math.floor(bounds.x)),
                                                        Math.min(Math.floor(bounds.height), canvas.height - Math.floor(bounds.y))
                                                      );

                                          // Detect text angle using advanced method
                                          const detectedAngle = detectTextAngleOpenCV(imageData);
                                          console.log('Detected text angle:', detectedAngle);

                                          // Deskew if angle is significant
                                          if (Math.abs(detectedAngle) > 0.5) {
                                                        imageData = deskewImage(imageData, detectedAngle);
                                          }

                                          // Preprocess image for better OCR
                                          const preprocessed = preprocessImageForOCR(imageData);

                                          // Perform OCR on preprocessed area
                                          const tempCanvas = document.createElement('canvas');
                                          tempCanvas.width = preprocessed.width;
                                          tempCanvas.height = preprocessed.height;
                                          const tempCtx = tempCanvas.getContext('2d');
                                          tempCtx.putImageData(preprocessed, 0, 0);

                                          const ocrResult = await Tesseract.recognize(
                                                        tempCanvas.toDataURL(),
                                                        'eng',
                                                        {
                                                                      logger: m => {
                                                                                    if (m.status === 'recognizing text') {
                                                                                                      setOcrProgress(Math.round(m.progress * 100));
                                                                                    }
                                                                      },
                                                                      tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                                                                      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?\'-"()[]{}/@#$%&*+=<>|\\/'
                                                        }
                                          );

                                          const text = ocrResult.data.text.trim();
                                          const confidence = ocrResult.data.confidence || 0;

                                          setDetectedText(text);
                                          setReplacementText(text);
                                          setOcrConfidence(confidence);

                                          console.log('OCR Result:', { text, confidence, angle: detectedAngle });

                                          const analysis = await performAdvancedAnalysis(imageData, bounds, selectionMask, detectedAngle);
                                          const tight = calculateTightTextBounds(imageData, bounds, detectedAngle, analysis.style.skew);
                                          setTightBounds(tight);

                                          // Use detected angle instead of estimated one
                                          const enhancedStyle = {
                                                        ...analysis.style,
                                                        rotation: detectedAngle
                                          };

                                          setDetectedStyle(enhancedStyle);
                                          setStyleSettings(prev => ({ ...prev, ...enhancedStyle }));
                                          setFontSuggestions(analysis.fontSuggestions);

                                          // Perform AI quality control checks
                                          const qualityReport = performQualityChecks(imageData, enhancedStyle, { confidence });
                                          setQualityChecks(qualityReport);
                              } catch (err) {
                                          console.error('Analysis error:', err);
                              }
                              setIsAnalyzing(false);
                              setOcrProgress(0);
                    };

                    const calculateTightTextBounds = (imageData, originalBounds, rotation, skew) => {
                              const data = imageData.data;
                              const width = imageData.width;
                              const height = imageData.height;
                              let minX = width, maxX = 0, minY = height, maxY = 0;
                              let foundText = false;
                              const edgeColors = [];
                              for (let x = 0; x < width; x++) {
                                          edgeColors.push(getLuminance(data, x, 0, width));
                                          edgeColors.push(getLuminance(data, x, height - 1, width));
                              }
                              for (let y = 0; y < height; y++) {
                                          edgeColors.push(getLuminance(data, 0, y, width));
                                          edgeColors.push(getLuminance(data, width - 1, y, width));
                              }
                              edgeColors.sort((a, b) => a - b);
                              const bgLuminance = edgeColors[Math.floor(edgeColors.length / 2)];
                              const threshold = Math.abs(bgLuminance - 128) < 64 ? 50 : 30;
                              for (let y = 0; y < height; y++) {
                                          for (let x = 0; x < width; x++) {
                                                        const lum = getLuminance(data, x, y, width);
                                                        if (Math.abs(lum - bgLuminance) > threshold) {
                                                                        foundText = true;
                                                                        minX = Math.min(minX, x);
                                                                        maxX = Math.max(maxX, x);
                                                                        minY = Math.min(minY, y);
                                                                        maxY = Math.max(maxY, y);
                                                        }
                                          }
                              }
                              if (!foundText) {
                                          return { x: originalBounds.x, y: originalBounds.y, width: originalBounds.width, height: originalBounds.height, rotation: rotation || 0, skew: skew || 0 };
                              }
                              const padding = 4;
                              minX = Math.max(0, minX - padding);
                              minY = Math.max(0, minY - padding);
                              maxX = Math.min(width, maxX + padding);
                              maxY = Math.min(height, maxY + padding);
                              return { x: originalBounds.x + minX, y: originalBounds.y + minY, width: maxX - minX, height: maxY - minY, rotation: rotation || 0, skew: skew || 0 };
                    };

                    const getLuminance = (data, x, y, width) => {
                              const idx = (y * width + x) * 4;
                              return 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                    };

                    const createPolygonMask = (points, bounds) => {
                              const width = Math.floor(bounds.width);
                              const height = Math.floor(bounds.height);
                              const mask = new Array(width * height).fill(false);
                              const localPoints = points.map(p => ({ x: p.x - bounds.x, y: p.y - bounds.y }));
                              for (let y = 0; y < height; y++) {
                                          for (let x = 0; x < width; x++) {
                                                        if (isPointInPolygon(x, y, localPoints)) mask[y * width + x] = true;
                                          }
                              }
                              return mask;
                    };

                    const isPointInPolygon = (x, y, polygon) => {
                              let inside = false;
                              for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                                          const xi = polygon[i].x, yi = polygon[i].y;
                                          const xj = polygon[j].x, yj = polygon[j].y;
                                          if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
                              }
                              return inside;
                    };

        const detectTextAngle = (imageData, mask) => {
                  const data = imageData.data;
                  const width = imageData.width;
                  const height = imageData.height;

                  // Simple edge detection using gradient approach
                  const gradients = [];

                  for (let y = 1; y < height - 1; y++) {
                              for (let x = 1; x < width - 1; x++) {
                                            if (mask && !mask[y * width + x]) continue;

                                            const idx = (y * width + x) * 4;
                                            const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];

                                            // Get neighboring pixels
                                            const lumLeft = 0.299 * data[(y * width + x - 1) * 4] + 0.587 * data[(y * width + x - 1) * 4 + 1] + 0.114 * data[(y * width + x - 1) * 4 + 2];
                                            const lumRight = 0.299 * data[(y * width + x + 1) * 4] + 0.587 * data[(y * width + x + 1) * 4 + 1] + 0.114 * data[(y * width + x + 1) * 4 + 2];
                                            const lumTop = 0.299 * data[((y - 1) * width + x) * 4] + 0.587 * data[((y - 1) * width + x) * 4 + 1] + 0.114 * data[((y - 1) * width + x) * 4 + 2];
                                            const lumBottom = 0.299 * data[((y + 1) * width + x) * 4] + 0.587 * data[((y + 1) * width + x) * 4 + 1] + 0.114 * data[((y + 1) * width + x) * 4 + 2];

                                            // Sobel-like gradients
                                            const gx = lumRight - lumLeft;
                                            const gy = lumBottom - lumTop;
                                            const magnitude = Math.sqrt(gx * gx + gy * gy);

                                            // Only consider strong edges
                                            if (magnitude > 30) {
                                                          const angle = Math.atan2(gy, gx) * (180 / Math.PI);
                                                          gradients.push(angle);
                                            }
                              }
                  }

                  if (gradients.length === 0) return 0;

                  // Build histogram (1-degree bins from -90 to 90)
                  const histogram = new Array(181).fill(0);
                  gradients.forEach(angle => {
                              const bin = Math.round(angle + 90);
                              if (bin >= 0 && bin < 181) histogram[bin]++;
                  });

                  // Find dominant angle (peak in histogram)
                  let maxCount = 0;
                  let dominantBin = 90; // Default to 0 degrees
                  for (let i = 0; i < histogram.length; i++) {
                              if (histogram[i] > maxCount) {
                                            maxCount = histogram[i];
                                            dominantBin = i;
                              }
                  }

                  // Convert bin back to angle
                  let detectedAngle = dominantBin - 90;

                  // Text baseline is perpendicular to gradient direction
                  // Adjust by 90 degrees to get text rotation angle
                  detectedAngle = (detectedAngle + 90) % 180;
                  if (detectedAngle > 90) detectedAngle -= 180;

                  // Clamp to -45 to +45 range
                  detectedAngle = Math.max(-45, Math.min(45, detectedAngle));

                  return detectedAngle;
        };

        const performAdvancedAnalysis = async (imageData, bounds, mask, providedAngle) => {
                  const data = imageData.data;
                  const width = imageData.width;
                  const height = imageData.height;
                  const colorAnalysis = analyzeColorsImproved(data, width, height, mask);
                  const textCharacteristics = analyzeTextCharacteristicsImproved(data, width, height, mask, colorAnalysis);

                  // Use provided angle from OpenCV if available, otherwise fallback to gradient method
                  const detectedAngle = providedAngle !== undefined ? providedAngle : detectTextAngle(imageData, mask);

                  const fontSuggestions = await suggestFonts(textCharacteristics, documentContext);
                  return {
                              style: {
                                            color: colorAnalysis.textColor,
                                            backgroundColor: colorAnalysis.bgColor,
                                            fontSize: textCharacteristics.estimatedSize,
                                            fontWeight: textCharacteristics.isBold ? 'bold' : 'normal',
                                            fontFamily: fontSuggestions[0]?.name || 'Arial',
                                            rotation: detectedAngle,
                                            skew: 0,
                                            letterSpacing: 0,
                              },
                              fontSuggestions,
                              textCharacteristics,
                  };
        };

                    const analyzeColorsImproved = (data, width, height, mask) => {
                              const edgePixels = [];
                              const edgeMargin = Math.max(2, Math.floor(Math.min(width, height) * 0.05));
                              for (let x = 0; x < width; x++) {
                                          for (let y = 0; y < edgeMargin; y++) {
                                                        const idx = (y * width + x) * 4;
                                                        if (!mask || mask[y * width + x]) {
                                                                        edgePixels.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                                                        }
                                          }
                                          for (let y = height - edgeMargin; y < height; y++) {
                                                        const idx = (y * width + x) * 4;
                                                        if (!mask || mask[y * width + x]) {
                                                                        edgePixels.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                                                        }
                                          }
                              }
                              for (let y = edgeMargin; y < height - edgeMargin; y++) {
                                          for (let x = 0; x < edgeMargin; x++) {
                                                        const idx = (y * width + x) * 4;
                                                        if (!mask || mask[y * width + x]) {
                                                                        edgePixels.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                                                        }
                                          }
                                          for (let x = width - edgeMargin; x < width; x++) {
                                                        const idx = (y * width + x) * 4;
                                                        if (!mask || mask[y * width + x]) {
                                                                        edgePixels.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                                                        }
                                          }
                              }
                              const bgColor = findDominantColor(edgePixels);
                              const bgLum = 0.299 * bgColor.r + 0.587 * bgColor.g + 0.114 * bgColor.b;
                              const centerPixels = [];
                              const centerMargin = Math.floor(Math.min(width, height) * 0.2);
                              for (let y = centerMargin; y < height - centerMargin; y++) {
                                          for (let x = centerMargin; x < width - centerMargin; x++) {
                                                        const idx = (y * width + x) * 4;
                                                        if (!mask || mask[y * width + x]) {
                                                                        const pixel = { r: data[idx], g: data[idx + 1], b: data[idx + 2] };
                                                                        const lum = 0.299 * pixel.r + 0.587 * pixel.g + 0.114 * pixel.b;
                                                                        if (Math.abs(lum - bgLum) > 30) {
                                                                                          centerPixels.push(pixel);
                                                                        }
                                                        }
                                          }
                              }
                              let textColor;
                              if (centerPixels.length > 10) {
                                          textColor = findDominantColor(centerPixels);
                              } else {
                                          textColor = bgLum > 128 ? { r: 0, g: 0, b: 0 } : { r: 255, g: 255, b: 255 };
                              }
                              const toHex = (c) => '#' + [c.r, c.g, c.b].map(v => Math.round(v).toString(16).padStart(2, '0')).join('');
                              return { textColor: toHex(textColor), bgColor: toHex(bgColor) };
                    };

                    const findDominantColor = (pixels) => {
                              if (pixels.length === 0) return { r: 255, g: 255, b: 255 };
                              const k = Math.min(3, pixels.length);
                              let centroids = pixels.slice(0, k).map(p => ({ ...p }));
                              for (let iter = 0; iter < 10; iter++) {
                                          const clusters = Array(k).fill(null).map(() => []);
                                          pixels.forEach(p => {
                                                        let minDist = Infinity;
                                                        let closest = 0;
                                                        centroids.forEach((c, i) => {
                                                                        const dist = Math.pow(p.r - c.r, 2) + Math.pow(p.g - c.g, 2) + Math.pow(p.b - c.b, 2);
                                                                        if (dist < minDist) { minDist = dist; closest = i; }
                                                        });
                                                        clusters[closest].push(p);
                                          });
                                          centroids = clusters.map((cluster, i) => {
                                                        if (cluster.length === 0) return centroids[i];
                                                        return {
                                                                        r: cluster.reduce((s, p) => s + p.r, 0) / cluster.length,
                                                                        g: cluster.reduce((s, p) => s + p.g, 0) / cluster.length,
                                                                        b: cluster.reduce((s, p) => s + p.b, 0) / cluster.length,
                                                        };
                                          });
                              }
                              const clusters = Array(k).fill(null).map(() => []);
                              pixels.forEach(p => {
                                          let minDist = Infinity;
                                          let closest = 0;
                                          centroids.forEach((c, i) => {
                                                        const dist = Math.pow(p.r - c.r, 2) + Math.pow(p.g - c.g, 2) + Math.pow(p.b - c.b, 2);
                                                        if (dist < minDist) { minDist = dist; closest = i; }
                                          });
                                          clusters[closest].push(p);
                              });
                              let maxSize = 0;
                              let dominantIdx = 0;
                              clusters.forEach((c, i) => { if (c.length > maxSize) { maxSize = c.length; dominantIdx = i; } });
                              return centroids[dominantIdx];
                    };

                    const analyzeTextCharacteristicsImproved = (data, width, height, mask, colorAnalysis) => {
                              const bgHex = colorAnalysis.bgColor;
                              const bgR = parseInt(bgHex.slice(1, 3), 16);
                              const bgG = parseInt(bgHex.slice(3, 5), 16);
                              const bgB = parseInt(bgHex.slice(5, 7), 16);
                              const bgLum = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB;
                              const rowHasText = [];
                              for (let y = 0; y < height; y++) {
                                          let hasText = false;
                                          for (let x = 0; x < width; x++) {
                                                        if (mask && !mask[y * width + x]) continue;
                                                        const idx = (y * width + x) * 4;
                                                        const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                                                        if (Math.abs(lum - bgLum) > 30) { hasText = true; break; }
                                          }
                                          rowHasText.push(hasText);
                              }
                              let maxConsecutive = 0;
                              let current = 0;
                              let textRowCounts = [];
                              for (let y = 0; y < height; y++) {
                                          if (rowHasText[y]) { current++; }
                                          else { if (current > 3) { textRowCounts.push(current); } maxConsecutive = Math.max(maxConsecutive, current); current = 0; }
                              }
                              if (current > 3) textRowCounts.push(current);
                              maxConsecutive = Math.max(maxConsecutive, current);
                              let estimatedSize;
                              if (textRowCounts.length > 0) {
                                          textRowCounts.sort((a, b) => a - b);
                                          estimatedSize = textRowCounts[Math.floor(textRowCounts.length / 2)];
                              } else { estimatedSize = Math.round(height * 0.7); }
                              estimatedSize = Math.max(10, Math.min(100, estimatedSize));
                              let strokeWidths = [];
                              for (let y = 0; y < height; y++) {
                                          let inStroke = false;
                                          let strokeStart = 0;
                                          for (let x = 0; x < width; x++) {
                                                        if (mask && !mask[y * width + x]) continue;
                                                        const idx = (y * width + x) * 4;
                                                        const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                                                        const isText = Math.abs(lum - bgLum) > 30;
                                                        if (isText && !inStroke) { inStroke = true; strokeStart = x; }
                                                        else if (!isText && inStroke) { inStroke = false; const sw = x - strokeStart; if (sw > 1 && sw < estimatedSize * 0.5) strokeWidths.push(sw); }
                                          }
                              }
                              const avgStrokeWidth = strokeWidths.length > 0 ? strokeWidths.reduce((a, b) => a + b, 0) / strokeWidths.length : 2;
                              const isBold = avgStrokeWidth > estimatedSize * 0.12;
                              const hasSerif = detectSerifs(data, width, height, bgLum);
                              return { estimatedSize, isBold, avgStrokeWidth, letterSpacing: 0, hasSerif, isItalic: false };
                    };

                                                  const detectSerifs = (data, width, height, bgLum) => {
                                                            let horizontalEdges = 0, verticalEdges = 0;
                                                            for (let y = 1; y < height - 1; y++) {
                                                                        for (let x = 1; x < width - 1; x++) {
                                                                                      const idx = (y * width + x) * 4;
                                                                                      const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                                                                                      if (Math.abs(lum - bgLum) < 30) continue;
                                                                                      const top = 0.299 * data[((y - 1) * width + x) * 4] + 0.587 * data[((y - 1) * width + x) * 4 + 1] + 0.114 * data[((y - 1) * width + x) * 4 + 2];
                                                                                      const bottom = 0.299 * data[((y + 1) * width + x) * 4] + 0.587 * data[((y + 1) * width + x) * 4 + 1] + 0.114 * data[((y + 1) * width + x) * 4 + 2];
                                                                                      const left = 0.299 * data[(y * width + x - 1) * 4] + 0.587 * data[(y * width + x - 1) * 4 + 1] + 0.114 * data[(y * width + x - 1) * 4 + 2];
                                                                                      const right = 0.299 * data[(y * width + x + 1) * 4] + 0.587 * data[(y * width + x + 1) * 4 + 1] + 0.114 * data[(y * width + x + 1) * 4 + 2];
                                                                                      if (Math.abs(top - bottom) > 30) verticalEdges++;
                                                                                      if (Math.abs(left - right) > 30) horizontalEdges++;
                                                                        }
                                                            }
                                                            return horizontalEdges > verticalEdges * 0.9;
                                                  };

                                                  const suggestFonts = async (characteristics, docContext) => {
                                                            const suggestions = [];
                                                            if (characteristics.hasSerif) {
                                                                        suggestions.push(
                                                                          { name: 'Times New Roman', confidence: 0.85, type: 'serif' },
                                                                          { name: 'Georgia', confidence: 0.75, type: 'serif' },
                                                                          { name: 'Garamond', confidence: 0.65, type: 'serif' },
                                                                                    );
                                                            } else {
                                                                        suggestions.push(
                                                                          { name: 'Arial', confidence: 0.85, type: 'sans-serif' },
                                                                          { name: 'Helvetica', confidence: 0.80, type: 'sans-serif' },
                                                                          { name: 'Verdana', confidence: 0.65, type: 'sans-serif' },
                                                                                    );
                                                            }
                                                            suggestions.sort((a, b) => b.confidence - a.confidence);
                                                            return suggestions.slice(0, 5);
                                                  };

              const generateText = async () => {
                        if (!replacementText) return;
                        setIsGenerating(true);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const overlay = { text: replacementText, style: { ...styleSettings } };
                        if (isPolygonClosed && polygonPoints.length >= 3) {
                                    const bounds = getPolygonBounds(polygonPoints);
                                    overlay.x = bounds.x; overlay.y = bounds.y;
                                    overlay.width = bounds.width; overlay.height = bounds.height;
                                    overlay.polygon = [...polygonPoints];
                        } else if (rectangleSelection) {
                                    overlay.x = rectangleSelection.x; overlay.y = rectangleSelection.y;
                                    overlay.width = rectangleSelection.width; overlay.height = rectangleSelection.height;
                        }
                        setPendingOverlay(overlay);
                        setShowConfirmation(true);
                        setIsGenerating(false);
              };

                                                  const confirmAndApply = () => {
                                                            if (pendingOverlay) {
                                                                        setGeneratedOverlay(pendingOverlay);
                                                                        setShowConfirmation(false);
                                                                        setPendingOverlay(null);
                                                                        setStep('preview');
                                                            }
                                                  };

                                                  const cancelConfirmation = () => {
                                                            setShowConfirmation(false);
                                                            setPendingOverlay(null);
                                                  };

                                                  const applyChanges = () => {
                                                            if (generatedOverlay) {
                                                                        setHistory(prev => [...prev, generatedOverlay]);
                                                                        setGeneratedOverlay(null);
                                                                        resetSelection();
                                                                        setReplacementText('');
                                                                        setStep('select');
                                                            }
                                                  };

                                                  const cancelChanges = () => {
                                                            setGeneratedOverlay(null);
                                                            setStep('edit');
                                                  };

                                                  const handleResetSelection = () => {
                                                            resetSelection();
                                                            setReplacementText('');
                                                            setStep('select');
                                                            setSelectionMode('rectangle');
                                                  };

                                                  const downloadImage = () => {
                                                            const canvas = canvasRef.current;
                                                            if (!canvas) return;
                                                            const link = document.createElement('a');
                                                            link.download = 'edited-image.png';
                                                            link.href = canvas.toDataURL('image/png');
                                                            link.click();
                                                  };

                                                  const undoLast = () => setHistory(prev => prev.slice(0, -1));
                                                  const triggerFileInput = () => fileInputRef.current?.click();

                                                  const hasSelection = (isPolygonClosed && polygonPoints.length >= 3) ||
                                                                               (rectangleSelection && rectangleSelection.width > 20 && rectangleSelection.height > 20);

                                                  return (
                                                            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 md:p-6">
                                                                        <div className="max-w-7xl mx-auto">
                                                                                      <div className="text-center mb-6">
                                                                                                      <h1 className="text-3xl md:text-4xl font-bold text-white mb-2">AI Text Editor</h1>
                                                                                                      <p className="text-slate-400 text-sm md:text-base">
                                                                                                                        Select text areas - AI automatically detects text, style, and rotation
                                                                                                        </p>
                                                                                        </div>

                                                                                      <div className="flex justify-center mb-6">
                                                                                                      <div className="flex items-center space-x-2 md:space-x-4">
                                                                                                        {['Upload', 'Select', 'Edit', 'Confirm', 'Preview'].map((label, i) => {
                                                                                const stepNames = ['upload', 'select', 'edit', 'confirm', 'preview'];
                                                                                const currentStepIdx = showConfirmation ? 3 : stepNames.indexOf(step);
                                                                                const isActive = currentStepIdx >= i;
                                                                                const isCurrent = currentStepIdx === i;
                                                                                return (
                                                                                                      <React.Fragment key={label}>
                                                                                                                              <div className={'flex items-center space-x-1 md:space-x-2 ' + (isActive ? 'text-blue-400' : 'text-slate-500')}>
                                                                                                                                                        <div className={'w-6 h-6 md:w-8 md:h-8 rounded-full flex items-center justify-center text-xs font-medium ' +
                                                                                                                                                                                    (isCurrent ? 'bg-blue-500 text-white' : isActive ? 'bg-blue-500/20 text-blue-400' : 'bg-slate-700 text-slate-500')}>
                                                                                                                                                          {i + 1}
                                                                                                                                                          </div>
                                                                                                                                                        <span className="text-xs font-medium hidden sm:inline">{label}</span>
                                                                                                                                </div>
                                                                                                        {i < 4 && <div className={'w-4 md:w-8 h-0.5 ' + (isActive && currentStepIdx > i ? 'bg-blue-500' : 'bg-slate-700')} />}
                                                                                                        </React.Fragment>
                                                                                                    );
                                                            })}
                                                                                                        </div>
                                                                                        </div>

                                                                                      <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 md:gap-6">
                                                                                                      <div className="lg:col-span-2">
                                                                                                                        <div className="bg-slate-800 rounded-2xl p-4 md:p-6 shadow-xl">
                                                                                                                                            <input ref={fileInputRef} type="file" accept="image/*" onChange={handleFileChange} className="hidden" />
                                                                                                                          
                                                                                                                          {!imageSrc ? (
                                                                                  <div onClick={triggerFileInput} className="flex flex-col items-center justify-center h-72 md:h-96 border-2 border-dashed border-slate-600 rounded-xl cursor-pointer hover:border-blue-500 hover:bg-slate-700/50 transition-all">
                                                                                                          <svg className="w-12 h-12 md:w-16 md:h-16 text-slate-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                                                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                                                                                            </svg>
                                                                                                          <span className="text-base md:text-lg font-medium text-slate-400 mb-2">Click to upload an image</span>
                                                                                                          <span className="text-xs md:text-sm text-slate-500">PNG, JPG, GIF supported</span>
                                                                                    </div>
                                                                                ) : (
                                                                                  <div className="relative">
                                                                                                          <canvas
                                                                                                                                    ref={canvasRef}
                                                                                                                                    className={'w-full h-auto rounded-lg border border-slate-700 ' + (showConfirmation ? 'cursor-not-allowed' : 'cursor-crosshair')}
                                                                                                                                    style={{ maxHeight: '65vh' }}
                                                                                                                                    onMouseDown={handleMouseDown}
                                                                                                                                    onMouseMove={handleMouseMove}
                                                                                                                                    onMouseUp={handleMouseUp}
                                                                                                                                    onMouseLeave={() => { if (isDragging) handleMouseUp({ clientX: 0, clientY: 0 }); }}
                                                                                                                                  />

                                                                                    {step === 'select' && !showConfirmation && (
                                                                                                            <div className="absolute top-3 left-3 bg-black/80 text-white px-3 py-2 rounded-lg text-xs space-y-1">
                                                                                                                                        <div className="flex items-center gap-2">
                                                                                                                                                                      <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                                                                                                                                                                      <span>Drag to select rectangle</span>
                                                                                                                                          </div>
                                                                                                                                        <div className="flex items-center gap-2">
                                                                                                                                                                      <span className="w-2 h-2 bg-green-500 rounded-full"></span>
                                                                                                                                                                      <span>Click to place polygon points</span>
                                                                                                                                          </div>
                                                                                                              {polygonPoints.length > 0 && !isPolygonClosed && (
                                                                                                                                          <div className="text-yellow-400 text-xs mt-1">
                                                                                                                                            {polygonPoints.length >= 3 ? 'Click near first point to close' : 'Place ' + (3 - polygonPoints.length) + ' more point(s)'}
                                                                                                                                            </div>
                                                                                                                                        )}
                                                                                                              </div>
                                                                                                          )}

                                                                                    {(isGenerating || isAnalyzing) && (
                                                                                                            <div className="absolute inset-0 bg-black/60 flex items-center justify-center rounded-lg">
                                                                                                                                        <div className="bg-slate-800 rounded-xl p-5 flex flex-col items-center min-w-[200px]">
                                                                                                                                                                      <div className="w-10 h-10 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-3" />
                                                                                                                                                                      <span className="text-white font-medium text-sm mb-2">
                                                                                                                                                                        {isAnalyzing ? (ocrProgress > 0 ? 'Detecting text...' : 'Analyzing style...') : 'Preparing preview...'}
                                                                                                                                                                      </span>
                                                                                                                                                                      {isAnalyzing && ocrProgress > 0 && (
                                                                                                                                                                        <div className="w-full bg-slate-700 rounded-full h-2 mb-1">
                                                                                                                                                                          <div className="bg-blue-500 h-2 rounded-full transition-all" style={{ width: ocrProgress + '%' }}></div>
                                                                                                                                                                        </div>
                                                                                                                                                                      )}
                                                                                                                                                                      {isAnalyzing && ocrProgress > 0 && (
                                                                                                                                                                        <span className="text-slate-400 text-xs">{ocrProgress}%</span>
                                                                                                                                                                      )}
                                                                                                                                          </div>
                                                                                                              </div>
                                                                                                          )}
                                                                                    </div>
                                                                                )}
                                                                                                                          </div>
                                                                                                        
                                                                                                        {imageSrc && !showConfirmation && (
                                                                                <div className="flex flex-wrap gap-2 md:gap-3 mt-3">
                                                                                                      <button onClick={triggerFileInput} className="px-3 py-2 bg-slate-700 text-white text-sm rounded-lg hover:bg-slate-600 transition-colors">Upload New</button>
                                                                                  {polygonPoints.length > 0 && !isPolygonClosed && (
                                                                                                        <button onClick={() => { setPolygonPoints([]); setSelectionMode('rectangle'); }} className="px-3 py-2 bg-red-600 text-white text-sm rounded-lg hover:bg-red-500 transition-colors">Clear Points</button>
                                                                                                      )}
                                                                                  {history.length > 0 && (
                                                                                                        <>
                                                                                                                                  <button onClick={undoLast} className="px-3 py-2 bg-amber-600 text-white text-sm rounded-lg hover:bg-amber-500 transition-colors">Undo</button>
                                                                                                                                  <button onClick={downloadImage} className="px-3 py-2 bg-green-600 text-white text-sm rounded-lg hover:bg-green-500 transition-colors">Download</button>
                                                                                                          </>
                                                                                                      )}
                                                                                  </div>
                                                                              )}
                                                                                                        
                                                                                                        {documentContext && !showConfirmation && (
                                                                                <div className="mt-4 bg-slate-800/50 rounded-xl p-3">
                                                                                                      <h4 className="text-xs font-medium text-slate-400 mb-2">Document Analysis</h4>
                                                                                                      <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                                                                                                              <div><span className="text-slate-500">Type:</span><span className="text-white ml-1 capitalize">{documentContext.documentType}</span></div>
                                                                                                                              <div><span className="text-slate-500">DPI:</span><span className="text-white ml-1">~{documentContext.estimatedDPI}</span></div>
                                                                                                                              <div><span className="text-slate-500">Text Density:</span><span className="text-white ml-1">{Math.round(documentContext.textDensity * 100)}%</span></div>
                                                                                                                              <div>
                                                                                                                                                        <span className="text-slate-500">OpenCV:</span>
                                                                                                                                                        <span className={'ml-1 font-semibold ' + (openCVReady ? 'text-green-400' : 'text-yellow-400')}>
                                                                                                                                                          {openCVReady ? '‚úì Ready' : '‚è≥ Loading...'}
                                                                                                                                                          </span>
                                                                                                                                </div>
                                                                                                        </div>
                                                                                  </div>
                                                                              )}
                                                                                                        </div>

                                                                                                      <div className="space-y-4">
                                                                                                        {showConfirmation && (
                                                                                <div className="bg-gradient-to-r from-red-900/50 to-orange-900/50 rounded-xl p-4 border border-red-500/50">
                                                                                                      <div className="flex items-center gap-3 mb-3">
                                                                                                                              <div className="w-8 h-8 bg-red-500/20 rounded-full flex items-center justify-center">
                                                                                                                                                        <svg className="w-5 h-5 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                                                                                                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                                                                                                                                          </svg>
                                                                                                                                </div>
                                                                                                                              <div>
                                                                                                                                                        <h3 className="text-white font-semibold">Confirm Replacement</h3>
                                                                                                                                                        <p className="text-red-300 text-xs">Red highlight shows area to replace</p>
                                                                                                                                </div>
                                                                                                        </div>
                                                                                                      <div className="bg-slate-900/50 rounded-lg p-3 mb-3">
                                                                                                                              <div className="text-xs text-slate-400 mb-1">New text:</div>
                                                                                                                              <div className="text-white text-sm font-medium">{pendingOverlay?.text}</div>
                                                                                                        </div>
                                                                                                      <div className="flex gap-2">
                                                                                                                              <button onClick={cancelConfirmation} className="flex-1 py-2 bg-slate-700 text-white rounded-lg hover:bg-slate-600 transition-colors text-sm">Cancel</button>
                                                                                                                              <button onClick={confirmAndApply} className="flex-1 py-2 bg-red-600 text-white rounded-lg hover:bg-red-500 transition-colors text-sm font-medium">Confirm</button>
                                                                                                        </div>
                                                                                  </div>
                                                                              )}
                                                                                                        
                                                                                                        {fontSuggestions.length > 0 && !showConfirmation && (
                                                                                <div className="bg-gradient-to-r from-purple-900/50 to-pink-900/50 rounded-xl p-4 border border-purple-500/30">
                                                                                                      <h3 className="text-sm font-semibold text-purple-400 mb-3">Suggested Fonts</h3>
                                                                                                      <div className="space-y-2">
                                                                                                        {fontSuggestions.map((font) => (
                                                                                                          <button key={font.name} onClick={() => setStyleSettings(prev => ({ ...prev, fontFamily: font.name }))}
                                                                                                                                      className={'w-full text-left px-3 py-2 rounded-lg text-sm transition-colors ' + (styleSettings.fontFamily === font.name ? 'bg-purple-600 text-white' : 'bg-slate-700/50 text-slate-300 hover:bg-slate-700')}>
                                                                                                                                      <div className="flex justify-between items-center">
                                                                                                                                                                    <span style={{ fontFamily: font.name }}>{font.name}</span>
                                                                                                                                                                    <span className="text-xs opacity-70">{Math.round(font.confidence * 100)}%</span>
                                                                                                                                        </div>
                                                                                                            </button>
                                                                                                        ))}
                                                                                                        </div>
                                                                                  </div>
                                                                              )}
                                                                                                        
                                                                                                        {detectedText && !showConfirmation && (
                                                                                <div className="bg-gradient-to-r from-green-900/50 to-emerald-900/50 rounded-xl p-4 border border-green-500/30">
                                                                                                      <h3 className="text-sm font-semibold text-green-400 mb-2">Detected Text (OCR)</h3>
                                                                                                      <div className="bg-slate-900/50 rounded-lg p-3 max-h-24 overflow-y-auto">
                                                                                                                              <p className="text-white text-sm whitespace-pre-wrap">{detectedText}</p>
                                                                                                        </div>
                                                                                                      <div className="flex items-center justify-between mt-2">
                                                                                                                              <p className="text-xs text-slate-500">Edit below to modify the detected text</p>
                                                                                                                              <div className="flex items-center gap-1">
                                                                                                                                                        <span className="text-xs text-slate-400">Confidence:</span>
                                                                                                                                                        <span className={'text-xs font-semibold ' + (ocrConfidence >= 80 ? 'text-green-400' : ocrConfidence >= 60 ? 'text-yellow-400' : 'text-red-400')}>
                                                                                                                                                          {ocrConfidence.toFixed(1)}%
                                                                                                                                                          </span>
                                                                                                                                </div>
                                                                                                        </div>
                                                                                  </div>
                                                                              )}

                                                                                                        {qualityChecks && !showConfirmation && (
                                                                                <div className="bg-gradient-to-r from-orange-900/50 to-red-900/50 rounded-xl p-4 border border-orange-500/30">
                                                                                                      <h3 className="text-sm font-semibold text-orange-400 mb-3">AI Quality Analysis</h3>

                                                                                                      {qualityChecks.warnings.length === 0 ? (
                                                                                                        <div className="flex items-center gap-2 text-green-400 text-sm">
                                                                                                          <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                                                                                                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                                                                                            </svg>
                                                                                                          <span>All quality checks passed!</span>
                                                                                                          </div>
                                                                                                      ) : (
                                                                                                        <div className="space-y-2">
                                                                                                          {qualityChecks.warnings.map((warning, idx) => (
                                                                                                                                    <div key={idx} className={'flex items-start gap-2 p-2 rounded-lg ' +
                                                                                                                                      (warning.severity === 'high' ? 'bg-red-900/30' : warning.severity === 'medium' ? 'bg-orange-900/30' : 'bg-yellow-900/30')}>
                                                                                                                                      <span className="text-lg">{warning.icon}</span>
                                                                                                                                      <div className="flex-1">
                                                                                                                                                                <p className="text-white text-xs font-medium">{warning.message}</p>
                                                                                                                                                                <p className="text-slate-400 text-xs mt-0.5 capitalize">{warning.type} issue</p>
                                                                                                                                        </div>
                                                                                                                                      </div>
                                                                                                            ))}
                                                                                                          </div>
                                                                                                      )}

                                                                                                      {qualityChecks.suggestions.length > 0 && (
                                                                                                        <>
                                                                                                          <h4 className="text-xs font-semibold text-orange-300 mt-3 mb-2">üí° Suggestions:</h4>
                                                                                                          <ul className="space-y-1">
                                                                                                                                    {qualityChecks.suggestions.map((suggestion, idx) => (
                                                                                                                                      <li key={idx} className="text-xs text-slate-300 flex items-start gap-2">
                                                                                                                                                                <span className="text-orange-400 mt-0.5">‚Ä¢</span>
                                                                                                                                                                <span>{suggestion}</span>
                                                                                                                                        </li>
                                                                                                                                    ))}
                                                                                                            </ul>
                                                                                                          </>
                                                                                                      )}

                                                                                                      <div className="grid grid-cols-3 gap-2 mt-3 pt-3 border-t border-orange-500/20">
                                                                                                        <div className="text-center">
                                                                                                          <div className="text-xs text-slate-400">Contrast</div>
                                                                                                          <div className={'text-sm font-bold ' + (qualityChecks.contrast.ratio >= 7 ? 'text-green-400' : qualityChecks.contrast.ratio >= 4.5 ? 'text-yellow-400' : 'text-red-400')}>
                                                                                                                                    {qualityChecks.contrast.ratio.toFixed(1)}:1
                                                                                                            </div>
                                                                                                          <div className="text-xs text-slate-500">{qualityChecks.contrast.rating}</div>
                                                                                                          </div>
                                                                                                        <div className="text-center">
                                                                                                          <div className="text-xs text-slate-400">Sharpness</div>
                                                                                                          <div className={'text-sm font-bold ' + (qualityChecks.blur.variance > 30 ? 'text-green-400' : qualityChecks.blur.variance > 15 ? 'text-yellow-400' : 'text-red-400')}>
                                                                                                                                    {qualityChecks.blur.variance.toFixed(1)}
                                                                                                            </div>
                                                                                                          <div className="text-xs text-slate-500 capitalize">{qualityChecks.blur.quality}</div>
                                                                                                          </div>
                                                                                                        <div className="text-center">
                                                                                                          <div className="text-xs text-slate-400">Readability</div>
                                                                                                          <div className={'text-sm font-bold ' + (qualityChecks.readability.score >= 80 ? 'text-green-400' : qualityChecks.readability.score >= 60 ? 'text-yellow-400' : 'text-red-400')}>
                                                                                                                                    {qualityChecks.readability.score}%
                                                                                                            </div>
                                                                                                          <div className="text-xs text-slate-500">{qualityChecks.readability.grade}</div>
                                                                                                          </div>
                                                                                                        </div>
                                                                                  </div>
                                                                              )}

                                                                                                        {detectedStyle && !showConfirmation && (
                                                                                <div className="bg-gradient-to-r from-blue-900/50 to-cyan-900/50 rounded-xl p-4 border border-blue-500/30">
                                                                                                      <h3 className="text-sm font-semibold text-blue-400 mb-3">Auto-Detected Style</h3>
                                                                                                      <div className="grid grid-cols-2 gap-2 text-xs">
                                                                                                                              <div className="flex items-center gap-2">
                                                                                                                                                        <span className="text-slate-400">Text:</span>
                                                                                                                                                        <span className="w-4 h-4 rounded border border-slate-600" style={{ backgroundColor: detectedStyle.color }}></span>
                                                                                                                                                        <span className="text-white">{detectedStyle.color}</span>
                                                                                                                                </div>
                                                                                                                              <div className="flex items-center gap-2">
                                                                                                                                                        <span className="text-slate-400">BG:</span>
                                                                                                                                                        <span className="w-4 h-4 rounded border border-slate-600" style={{ backgroundColor: detectedStyle.backgroundColor }}></span>
                                                                                                                                                        <span className="text-white">{detectedStyle.backgroundColor}</span>
                                                                                                                                </div>
                                                                                                                              <div><span className="text-slate-400">Size:</span><span className="text-white ml-1">{detectedStyle.fontSize}px (auto)</span></div>
                                                                                                                              <div><span className="text-slate-400">Weight:</span><span className="text-white ml-1 capitalize">{detectedStyle.fontWeight} (auto)</span></div>
                                                                                                                              <div><span className="text-slate-400">Rotation:</span><span className="text-white ml-1">{Math.round(detectedStyle.rotation)}¬∞ (auto)</span></div>
                                                                                                                              <div><span className="text-slate-400">Skew:</span><span className="text-white ml-1">{Math.round(detectedStyle.skew)}¬∞ (auto)</span></div>
                                                                                                        </div>
                                                                                                      <p className="text-xs text-slate-500 mt-2">All text properties detected automatically</p>
                                                                                  </div>
                                                                              )}
                                                                                                        
                                                                                                                        <div className="bg-slate-800 rounded-xl p-4 shadow-xl">
                                                                                                                                            <h3 className="text-base font-semibold text-white mb-3">Replacement Text</h3>
                                                                                                                                            <textarea value={replacementText} onChange={(e) => setReplacementText(e.target.value)} placeholder="Enter the new text..."
                                                                                                                                                                  disabled={step === 'upload' || step === 'preview' || showConfirmation}
                                                                                                                                                                  className="w-full h-20 bg-slate-700 text-white rounded-lg p-3 text-sm resize-none focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:opacity-50" />
                                                                                                                          </div>
                                                                                                        
                                                                                                                        <div className="bg-slate-800 rounded-xl p-4 shadow-xl">
                                                                                                                                            <h3 className="text-base font-semibold text-white mb-3">Style Settings</h3>
                                                                                                                                            <div className="space-y-3">
                                                                                                                                                                  <div>
                                                                                                                                                                                          <label className="text-xs text-slate-400 mb-1 block">Font Family</label>
                                                                                                                                                                                          <select value={styleSettings.fontFamily} onChange={(e) => setStyleSettings(prev => ({ ...prev, fontFamily: e.target.value }))}
                                                                                                                                                                                                                    disabled={showConfirmation} className="w-full bg-slate-700 text-white text-sm rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:opacity-50">
                                                                                                                                                                                                                    {['Arial', 'Helvetica', 'Times New Roman', 'Georgia', 'Verdana', 'Courier New', 'Calibri', 'Garamond', 'Impact', 'Comic Sans MS'].map(f => (
                                                                                                                                                                                                                                                <option key={f} value={f}>{f}</option>
                                                                                                                                                                                                                                              ))}
                                                                                                                                                                                                                  </select>
                                                                                                                                                                    </div>
                                                                                                                                                                  <div className="grid grid-cols-2 gap-3">
                                                                                                                                                                                          <div>
                                                                                                                                                                                                                    <label className="text-xs text-slate-400 mb-1 block">Size (Auto-detected)</label>
                                                                                                                                                                                                                    <input type="number" value={styleSettings.fontSize} readOnly
                                                                                                                                                                                                                                                className="w-full bg-slate-700/50 text-white text-sm rounded-lg p-2 cursor-not-allowed opacity-75" />
                                                                                                                                                                                                                  </div>
                                                                                                                                                                                          <div>
                                                                                                                                                                                                                    <label className="text-xs text-slate-400 mb-1 block">Weight (Auto-detected)</label>
                                                                                                                                                                                                                    <input type="text" value={styleSettings.fontWeight} readOnly
                                                                                                                                                                                                                                                className="w-full bg-slate-700/50 text-white text-sm rounded-lg p-2 cursor-not-allowed opacity-75 capitalize" />
                                                                                                                                                                                                                  </div>
                                                                                                                                                                    </div>
                                                                                                                                                                  <div className="grid grid-cols-2 gap-3">
                                                                                                                                                                                          <div>
                                                                                                                                                                                                                    <label className="text-xs text-slate-400 mb-1 block">Text Color</label>
                                                                                                                                                                                                                    <div className="flex items-center gap-2">
                                                                                                                                                                                                                                                <input type="color" value={styleSettings.color} onChange={(e) => setStyleSettings(prev => ({ ...prev, color: e.target.value }))}
                                                                                                                                                                                                                                                                              disabled={showConfirmation} className="w-8 h-8 rounded cursor-pointer border-0 bg-transparent disabled:opacity-50" />
                                                                                                                                                                                                                                                <input type="text" value={styleSettings.color} onChange={(e) => setStyleSettings(prev => ({ ...prev, color: e.target.value }))}
                                                                                                                                                                                                                                                                              disabled={showConfirmation} className="flex-1 bg-slate-700 text-white text-xs rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:opacity-50" />
                                                                                                                                                                                                                                              </div>
                                                                                                                                                                                                                  </div>
                                                                                                                                                                                          <div>
                                                                                                                                                                                                                    <label className="text-xs text-slate-400 mb-1 block">Background</label>
                                                                                                                                                                                                                    <div className="flex items-center gap-2">
                                                                                                                                                                                                                                                <input type="color" value={styleSettings.backgroundColor} onChange={(e) => setStyleSettings(prev => ({ ...prev, backgroundColor: e.target.value }))}
                                                                                                                                                                                                                                                                              disabled={showConfirmation} className="w-8 h-8 rounded cursor-pointer border-0 bg-transparent disabled:opacity-50" />
                                                                                                                                                                                                                                                <input type="text" value={styleSettings.backgroundColor} onChange={(e) => setStyleSettings(prev => ({ ...prev, backgroundColor: e.target.value }))}
                                                                                                                                                                                                                                                                              disabled={showConfirmation} className="flex-1 bg-slate-700 text-white text-xs rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:opacity-50" />
                                                                                                                                                                                                                                              </div>
                                                                                                                                                                                                                  </div>
                                                                                                                                                                    </div>
                                                                                                                                              </div>
                                                                                                                          </div>
                                                                                                        
                                                                                                        {!showConfirmation && (
                                                                                <div className="space-y-2">
                                                                                  {step === 'edit' && (
                                                                                                        <>
                                                                                                                                  <button onClick={generateText} disabled={!replacementText || isGenerating || !hasSelection}
                                                                                                                                                              className="w-full py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-xl font-semibold hover:from-blue-500 hover:to-purple-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all">
                                                                                                                                    {isGenerating ? 'Preparing...' : 'Preview Replacement'}
                                                                                                                                    </button>
                                                                                                                                  <button onClick={handleResetSelection} className="w-full py-2.5 bg-slate-700 text-white text-sm rounded-xl hover:bg-slate-600 transition-colors">Reset Selection</button>
                                                                                                          </>
                                                                                                      )}
                                                                                  {step === 'preview' && (
                                                                                                        <>
                                                                                                                                  <button onClick={applyChanges} className="w-full py-3 bg-green-600 text-white rounded-xl font-semibold hover:bg-green-500 transition-all">Apply Changes</button>
                                                                                                                                  <button onClick={cancelChanges} className="w-full py-2.5 bg-slate-700 text-white text-sm rounded-xl hover:bg-slate-600 transition-colors">Cancel</button>
                                                                                                          </>
                                                                                                      )}
                                                                                  </div>
                                                                              )}
                                                                                                        
                                                                                                        {(polygonPoints.length > 0 || rectangleSelection) && !showConfirmation && (
                                                                                <div className="bg-slate-800/50 rounded-xl p-3">
                                                                                                      <h4 className="text-xs font-medium text-slate-400 mb-2">Selection</h4>
                                                                                                      <div className="text-xs">
                                                                                                        {isPolygonClosed ? (
                                                                                                          <span className="text-green-400">Polygon with {polygonPoints.length} points (closed)</span>
                                                                                                        ) : polygonPoints.length > 0 ? (
                                                                                                          <span className="text-yellow-400">Polygon with {polygonPoints.length} points (open)</span>
                                                                                                        ) : rectangleSelection ? (
                                                                                                          <span className="text-blue-400">Rectangle: {Math.round(rectangleSelection.width)} x {Math.round(rectangleSelection.height)}</span>
                                                                                                        ) : null}
                                                                                                        </div>
                                                                                  </div>
                                                                              )}
                                                                                                        </div>
                                                                                        </div>

                                                                                      <div className="mt-6 bg-slate-800/50 rounded-xl p-4">
                                                                                                      <h3 className="text-base font-semibold text-white mb-3">How to Use</h3>
                                                                                                      <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                                                                                                        {[
                                                              { n: 1, title: 'Upload', desc: 'Upload an image', icon: 'U' },
                                                              { n: 2, title: 'Select', desc: 'Drag or click points', icon: 'S' },
                                                              { n: 3, title: 'Edit', desc: 'Adjust detected styles', icon: 'E' },
                                                              { n: 4, title: 'Confirm', desc: 'Review highlighted area', icon: 'C' },
                                                              { n: 5, title: 'Apply', desc: 'Apply and download', icon: 'A' },
                                                                              ].map(({ n, title, desc, icon }) => (
                                                                                                  <div key={n} className="flex items-start space-x-2">
                                                                                                                        <div className="w-7 h-7 bg-blue-500/20 rounded flex items-center justify-center text-sm flex-shrink-0 text-blue-400">{icon}</div>
                                                                                                                        <div>
                                                                                                                                                <h4 className="text-white text-sm font-medium">{title}</h4>
                                                                                                                                                <p className="text-xs text-slate-400">{desc}</p>
                                                                                                                          </div>
                                                                                                    </div>
                                                                                                ))}
                                                                                                        </div>
                                                                                        </div>
                                                                        </div>
                                                            </div>
                                                          );
                                          }

                                    ReactDOM.createRoot(document.getElementById('root')).render(<TextEditorPrototype />);
                                </script>
    </body>
  </html>
