<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Text Editor V4 Enhanced - Zero Config</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: 'Inter', sans-serif; }
        .canvas-bg {
            background-image: radial-gradient(#334155 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .animate-pulse-fast { animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-up { animation: fadeInUp 0.3s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- ENHANCED OCR PREPROCESSING (7-STEP PIPELINE) ---
        const preprocessImageForOCR = (canvas) => {
            return new Promise((resolve) => {
                if (typeof cv === 'undefined') {
                    console.warn('OpenCV not loaded, using original image');
                    resolve(canvas.toDataURL());
                    return;
                }

                try {
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    let src = cv.matFromImageData(imageData);

                    // STEP 1: Upscale if too small
                    if (src.cols < 200 || src.rows < 60) {
                        const scale = Math.max(200 / src.cols, 60 / src.rows, 2.0);
                        const upscaled = new cv.Mat();
                        const dsize = new cv.Size(src.cols * scale, src.rows * scale);
                        cv.resize(src, upscaled, dsize, 0, 0, cv.INTER_CUBIC);
                        src.delete();
                        src = upscaled;
                        console.log(`üìà Upscaled ${scale.toFixed(2)}x for better OCR`);
                    }

                    const gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                    // STEP 2: Bilateral filter (noise reduction)
                    const bilateral = new cv.Mat();
                    cv.bilateralFilter(gray, bilateral, 9, 75, 75);

                    // STEP 3: CLAHE (contrast enhancement)
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    const enhanced = new cv.Mat();
                    clahe.apply(bilateral, enhanced);

                    // STEP 4: Unsharp masking (sharpening)
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(enhanced, blurred, new cv.Size(0, 0), 3);
                    const sharpened = new cv.Mat();
                    cv.addWeighted(enhanced, 1.5, blurred, -0.5, 0, sharpened);

                    // STEP 5: Otsu's binarization
                    const binary = new cv.Mat();
                    cv.threshold(sharpened, binary, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

                    // STEP 6: Morphological cleanup
                    const kernel1 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, 1));
                    const opened = new cv.Mat();
                    cv.morphologyEx(binary, opened, cv.MORPH_OPEN, kernel1);

                    const kernel2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const closed = new cv.Mat();
                    cv.morphologyEx(opened, closed, cv.MORPH_CLOSE, kernel2);

                    // STEP 7: Border padding
                    const padded = new cv.Mat();
                    cv.copyMakeBorder(closed, padded, 10, 10, 10, 10, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));

                    // Convert back to canvas
                    const rgba = new cv.Mat();
                    cv.cvtColor(padded, rgba, cv.COLOR_GRAY2RGBA);

                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = rgba.cols;
                    resultCanvas.height = rgba.rows;
                    const resultCtx = resultCanvas.getContext('2d');
                    const resultImageData = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);
                    resultCtx.putImageData(resultImageData, 0, 0);

                    // Cleanup
                    src.delete(); gray.delete(); bilateral.delete(); enhanced.delete();
                    blurred.delete(); sharpened.delete(); binary.delete();
                    kernel1.delete(); opened.delete(); kernel2.delete(); closed.delete();
                    padded.delete(); rgba.delete();

                    resolve(resultCanvas.toDataURL());
                } catch (error) {
                    console.error('Preprocessing error:', error);
                    resolve(canvas.toDataURL());
                }
            });
        };

        // --- POST-PROCESS OCR TEXT ---
        const postProcessOCRText = (text) => {
            if (!text) return '';
            let cleaned = text.replace(/\s+/g, ' '); // Remove excessive whitespace

            // Fix common OCR character substitutions
            cleaned = cleaned.replace(/([a-zA-Z])0([a-zA-Z])/g, '$1O$2');  // 0 -> O
            cleaned = cleaned.replace(/([a-zA-Z])1([a-zA-Z])/g, '$1l$2');  // 1 -> l
            cleaned = cleaned.replace(/([a-zA-Z])5([a-zA-Z])/g, '$1S$2');  // 5 -> S
            cleaned = cleaned.replace(/([a-zA-Z])8([a-zA-Z])/g, '$1B$2');  // 8 -> B
            cleaned = cleaned.replace(/\|/g, 'I');  // | -> I

            // Fix common word errors
            const wordFixes = {
                'tlie': 'the', 'Tlie': 'The',
                'witli': 'with', 'Witli': 'With',
                'wliich': 'which', 'Wliich': 'Which',
                'wliat': 'what', 'Wliat': 'What',
                'tliat': 'that', 'Tliat': 'That',
                'liave': 'have', 'Liave': 'Have',
                'tliis': 'this', 'Tliis': 'This'
            };

            Object.entries(wordFixes).forEach(([wrong, right]) => {
                const regex = new RegExp('\\b' + wrong + '\\b', 'g');
                cleaned = cleaned.replace(regex, right);
            });

            // Capitalize first letter if lowercase
            if (cleaned.length > 0 && /^[a-z]/.test(cleaned)) {
                cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
            }

            // Remove leading/trailing junk
            cleaned = cleaned.replace(/^[,.\-:;]+/, '').replace(/[,.\-:;]+$/, '');

            return cleaned.trim();
        };

        // --- ENHANCED PIXEL ANALYSIS ---
        const analyzePixelData = (ctx, bounds, ocrWords) => {
            const imgData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
            const data = imgData.data;

            // Sample edges for background
            let bgR=0, bgG=0, bgB=0, bgCount=0;
            const borderSize = Math.min(bounds.width, bounds.height) * 0.1;

            for(let y=0; y<bounds.height; y++) {
                for(let x=0; x<bounds.width; x++) {
                    if (x < borderSize || x > bounds.width - borderSize ||
                        y < borderSize || y > bounds.height - borderSize) {
                        const i = (y * bounds.width + x) * 4;
                        bgR += data[i]; bgG += data[i+1]; bgB += data[i+2];
                        bgCount++;
                    }
                }
            }
            const avgBg = {
                r: Math.round(bgR/bgCount),
                g: Math.round(bgG/bgCount),
                b: Math.round(bgB/bgCount)
            };

            // Find text color
            let textR=0, textG=0, textB=0, textCount=0;
            const threshold = 50;

            for(let i=0; i<data.length; i+=4) {
                const diff = Math.abs(data[i] - avgBg.r) +
                            Math.abs(data[i+1] - avgBg.g) +
                            Math.abs(data[i+2] - avgBg.b);
                if(diff > threshold) {
                    textR += data[i]; textG += data[i+1]; textB += data[i+2];
                    textCount++;
                }
            }

            const avgText = textCount > 0
                ? { r: Math.round(textR/textCount), g: Math.round(textG/textCount), b: Math.round(textB/textCount) }
                : { r: 0, g: 0, b: 0 };

            const textColorHex = `#${((1 << 24) + (avgText.r << 16) + (avgText.g << 8) + avgText.b).toString(16).slice(1)}`;

            // Boldness detection - sample multiple horizontal lines
            let strokeWidths = [];
            const sampleLines = [0.3, 0.5, 0.7]; // Sample at 30%, 50%, 70% height

            sampleLines.forEach(ratio => {
                let inkRun = 0;
                const y = Math.floor(bounds.height * ratio);
                for(let x=0; x<bounds.width; x++) {
                    const i = (y * bounds.width + x) * 4;
                    const isInk = (Math.abs(data[i] - avgBg.r) +
                                  Math.abs(data[i+1] - avgBg.g) +
                                  Math.abs(data[i+2] - avgBg.b)) > threshold;
                    if(isInk) inkRun++;
                    else if(inkRun > 0) { strokeWidths.push(inkRun); inkRun = 0; }
                }
            });

            const avgStrokeWidth = strokeWidths.length ?
                strokeWidths.reduce((a,b)=>a+b)/strokeWidths.length : 1;
            const isBold = avgStrokeWidth > (bounds.height * 0.08);

            // Serif detection
            const variance = strokeWidths.length ?
                strokeWidths.reduce((a,b) => a + Math.pow(b - avgStrokeWidth, 2), 0) / strokeWidths.length : 0;
            const isSerif = variance > 3;

            return {
                color: textColorHex,
                fontWeight: isBold ? 'bold' : 'normal',
                fontFamily: isSerif ? 'Times New Roman' : 'Arial',
                bgColor: `rgb(${avgBg.r},${avgBg.g},${avgBg.b})`
            };
        };

        function App() {
            const [file, setFile] = useState(null);
            const [status, setStatus] = useState('IDLE');
            const [statusMsg, setStatusMsg] = useState('');
            const [ocrProgress, setOcrProgress] = useState(0);

            const [selection, setSelection] = useState(null);
            const [autoStyle, setAutoStyle] = useState(null);
            const [replacementText, setReplacementText] = useState('');
            const [originalText, setOriginalText] = useState('');
            const [confidence, setConfidence] = useState(0);

            const canvasRef = useRef(null);
            const imgRef = useRef(null);
            const [drag, setDrag] = useState(null);
            const [history, setHistory] = useState([]);
            const [cvReady, setCvReady] = useState(false);

            // Check OpenCV status
            useEffect(() => {
                const checkCV = setInterval(() => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        setCvReady(true);
                        console.log('‚úÖ OpenCV.js ready');
                        clearInterval(checkCV);
                    }
                }, 100);
                setTimeout(() => clearInterval(checkCV), 30000);
                return () => clearInterval(checkCV);
            }, []);

            const handleFile = async (e) => {
                const f = e.target.files[0];
                if (!f) return;
                setStatus('PROCESSING');
                setStatusMsg('Loading Document...');

                if(f.type === 'application/pdf') {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const pdf = await pdfjsLib.getDocument(ev.target.result).promise;
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 2.0 });
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        loadImage(canvas.toDataURL());
                    };
                    reader.readAsArrayBuffer(f);
                } else {
                    const reader = new FileReader();
                    reader.onload = (ev) => loadImage(ev.target.result);
                    reader.readAsDataURL(f);
                }
            };

            const loadImage = (src) => {
                const img = new Image();
                img.onload = () => {
                    imgRef.current = img;
                    setFile(src);
                    setStatus('IDLE');
                    setHistory([]);
                    setSelection(null);
                    draw();
                };
                img.src = src;
            };

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const img = imgRef.current;
                if (!canvas || !img) return;

                const ctx = canvas.getContext('2d');
                if (canvas.width !== img.naturalWidth) {
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                }

                ctx.clearRect(0,0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                history.forEach(edit => renderEdit(ctx, edit));

                if (status === 'EDITING' && autoStyle) {
                    renderEdit(ctx, {
                        rect: selection,
                        text: replacementText,
                        style: autoStyle
                    }, true);
                }

                if (drag) {
                    const w = drag.end.x - drag.start.x;
                    const h = drag.end.y - drag.start.y;
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(drag.start.x, drag.start.y, w, h);
                    ctx.setLineDash([]);
                }
            }, [file, drag, history, status, autoStyle, replacementText]);

            useEffect(() => draw(), [draw]);

            const renderEdit = (ctx, edit, isPreview = false) => {
                const { rect, text, style } = edit;
                ctx.save();

                ctx.fillStyle = style.bgColor || '#fff';
                ctx.translate(rect.x + rect.w/2, rect.y + rect.h/2);
                ctx.rotate((style.rotation * Math.PI) / 180);
                ctx.fillRect(-rect.w/2, -rect.h/2, rect.w, rect.h);

                if (text) {
                    ctx.font = `${style.fontWeight} ${style.fontSize}px ${style.fontFamily}`;
                    ctx.fillStyle = style.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const metrics = ctx.measureText(text);
                    if (metrics.width > rect.w - 20) {
                        const scale = (rect.w - 20) / metrics.width;
                        ctx.scale(scale, 1);
                    }

                    ctx.fillText(text, 0, 0);
                }

                if (isPreview) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-rect.w/2, -rect.h/2, rect.w, rect.h);
                }

                ctx.restore();
            };

            const processSelection = async (rect) => {
                setStatus('PROCESSING');
                setStatusMsg('Enhancing image quality...');

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                // Extract snippet
                const snippet = document.createElement('canvas');
                snippet.width = rect.w;
                snippet.height = rect.h;
                snippet.getContext('2d').drawImage(canvas, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);

                try {
                    // ENHANCED PREPROCESSING
                    setStatusMsg('Applying 7-step enhancement pipeline...');
                    const enhanced = await preprocessImageForOCR(snippet);

                    // OCR with better config
                    setStatusMsg('Recognizing text with AI...');
                    const result = await Tesseract.recognize(enhanced, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                setOcrProgress(Math.round(m.progress * 100));
                            }
                        },
                        tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                        preserve_interword_spaces: '1'
                    });

                    // POST-PROCESS TEXT
                    const rawText = result.data.text.trim();
                    const cleanedText = postProcessOCRText(rawText);
                    const lines = result.data.lines;
                    const conf = result.data.confidence || 0;

                    console.log('üìù Raw OCR:', rawText);
                    console.log('‚ú® Cleaned:', cleanedText);
                    console.log('üìä Confidence:', conf.toFixed(1) + '%');

                    // Auto-Detect Rotation
                    let rotation = 0;
                    if (lines.length > 0 && lines[0]?.baseline) {
                        const bl = lines[0].baseline;
                        rotation = Math.atan2(bl.y1 - bl.y0, bl.x1 - bl.x0) * (180/Math.PI);
                        rotation = Math.max(-45, Math.min(45, rotation)); // Clamp
                    }

                    // Pixel Analysis
                    setStatusMsg('Analyzing colors and styles...');
                    const pixelStyle = analyzePixelData(ctx,
                        {x: rect.x, y: rect.y, width: rect.w, height: rect.h},
                        result.data.words
                    );

                    // Font Size
                    const lineCount = lines.length || 1;
                    let estimatedFontSize = (rect.h / lineCount) * 0.75;

                    // Better: use actual bbox if available
                    if (lines.length > 0 && lines[0].bbox) {
                        estimatedFontSize = Math.round(lines[0].bbox.y1 - lines[0].bbox.y0);
                    }

                    const finalStyle = {
                        ...pixelStyle,
                        rotation: rotation,
                        fontSize: Math.max(10, Math.min(100, Math.round(estimatedFontSize)))
                    };

                    setOriginalText(cleanedText);
                    setReplacementText(cleanedText);
                    setAutoStyle(finalStyle);
                    setConfidence(conf);
                    setSelection(rect);
                    setStatus('EDITING');

                } catch (err) {
                    console.error(err);
                    alert("Could not analyze text. Try selecting a clearer area.");
                    setStatus('IDLE');
                }
            };

            const getCoords = (e) => {
                const r = canvasRef.current.getBoundingClientRect();
                const sx = canvasRef.current.width / r.width;
                const sy = canvasRef.current.height / r.height;
                return { x: (e.clientX - r.left)*sx, y: (e.clientY - r.top)*sy };
            };

            const onDown = (e) => {
                if(status !== 'IDLE') return;
                const p = getCoords(e);
                setDrag({ start: p, end: p });
            };

            const onMove = (e) => {
                if(!drag) return;
                setDrag({ ...drag, end: getCoords(e) });
            };

            const onUp = () => {
                if(!drag) return;
                const w = Math.abs(drag.end.x - drag.start.x);
                const h = Math.abs(drag.end.y - drag.start.y);
                if(w > 10 && h > 10) {
                    const rect = {
                        x: Math.min(drag.start.x, drag.end.x),
                        y: Math.min(drag.start.y, drag.end.y),
                        w, h
                    };
                    setDrag(null);
                    processSelection(rect);
                } else {
                    setDrag(null);
                }
            };

            const apply = () => {
                setHistory([...history, {
                    rect: selection,
                    text: replacementText,
                    style: autoStyle
                }]);
                setStatus('IDLE');
                setSelection(null);
            };

            return (
                <div className="flex h-screen overflow-hidden">
                    <div className="w-80 bg-slate-900 border-r border-slate-800 p-6 flex flex-col shadow-2xl z-10">
                        <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-400 to-indigo-400 bg-clip-text text-transparent mb-1">
                            Magic Editor
                        </h1>
                        <p className="text-xs text-slate-500 mb-2">Enhanced AI Text Replacement</p>

                        {cvReady ? (
                            <div className="text-[10px] text-green-400 mb-6 flex items-center gap-1">
                                <span>‚úì</span> OpenCV Active - Full Enhancement
                            </div>
                        ) : (
                            <div className="text-[10px] text-yellow-400 mb-6 flex items-center gap-1">
                                <span>‚è≥</span> OpenCV Loading...
                            </div>
                        )}

                        {!file ? (
                            <div className="flex-1 flex flex-col items-center justify-center border-2 border-dashed border-slate-700 rounded-xl hover:bg-slate-800/50 transition cursor-pointer relative">
                                <input type="file" onChange={handleFile} className="absolute inset-0 opacity-0 cursor-pointer" accept="image/*,application/pdf" />
                                <div className="text-4xl mb-3">üìÑ</div>
                                <span className="text-sm font-medium text-slate-400">Upload Image / PDF</span>
                            </div>
                        ) : (
                            <div className="space-y-6">
                                {status === 'IDLE' && (
                                    <div className="bg-blue-900/20 border border-blue-500/30 p-4 rounded-lg text-sm text-blue-200">
                                        <div className="font-semibold mb-2">üéØ How to use:</div>
                                        <ol className="text-xs space-y-1 ml-4 list-decimal">
                                            <li>Draw a box around text</li>
                                            <li>AI analyzes everything automatically</li>
                                            <li>Edit text & apply changes</li>
                                        </ol>
                                    </div>
                                )}

                                {status === 'PROCESSING' && (
                                    <div className="text-center py-10">
                                        <div className="animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-3"></div>
                                        <div className="text-sm text-slate-400 animate-pulse-fast mb-2">{statusMsg}</div>
                                        {ocrProgress > 0 && (
                                            <div className="mt-4">
                                                <div className="w-full bg-slate-700 rounded-full h-2 mb-1">
                                                    <div className="bg-blue-500 h-2 rounded-full transition-all" style={{width: ocrProgress + '%'}}></div>
                                                </div>
                                                <div className="text-xs text-slate-500">{ocrProgress}%</div>
                                            </div>
                                        )}
                                    </div>
                                )}

                                {status === 'EDITING' && (
                                    <div className="space-y-4 animate-fade-in-up">
                                        <div>
                                            <label className="text-xs font-bold text-slate-500 uppercase tracking-wider">Detected Text</label>
                                            <div className="text-xs text-slate-400 italic mt-1 bg-slate-950 p-2 rounded border border-slate-800">
                                                "{originalText}"
                                            </div>
                                            <div className="flex items-center gap-2 mt-1">
                                                <span className="text-[10px] text-slate-500">Confidence:</span>
                                                <span className={'text-xs font-bold ' + (confidence >= 80 ? 'text-green-400' : confidence >= 60 ? 'text-yellow-400' : 'text-red-400')}>
                                                    {confidence.toFixed(1)}%
                                                </span>
                                            </div>
                                        </div>

                                        <div>
                                            <label className="text-xs font-bold text-slate-500 uppercase tracking-wider">New Text</label>
                                            <textarea
                                                value={replacementText}
                                                onChange={e => setReplacementText(e.target.value)}
                                                className="w-full h-32 bg-slate-800 border border-slate-700 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none mt-2"
                                                autoFocus
                                            />
                                        </div>

                                        <div className="bg-slate-800/50 p-3 rounded-lg border border-slate-700">
                                            <div className="text-xs font-bold text-slate-400 mb-2">Auto-Detected Style</div>
                                            <div className="grid grid-cols-2 gap-2 text-[10px] text-slate-300">
                                                <div className="flex items-center gap-1">
                                                    <span className="text-slate-500">Font:</span>
                                                    <span className="font-medium">{autoStyle.fontFamily}</span>
                                                </div>
                                                <div className="flex items-center gap-1">
                                                    <span className="text-slate-500">Size:</span>
                                                    <span className="font-medium">{autoStyle.fontSize}px</span>
                                                </div>
                                                <div className="flex items-center gap-1">
                                                    <span className="text-slate-500">Weight:</span>
                                                    <span className="font-medium capitalize">{autoStyle.fontWeight}</span>
                                                </div>
                                                <div className="flex items-center gap-1">
                                                    <span className="text-slate-500">Angle:</span>
                                                    <span className="font-medium">{autoStyle.rotation.toFixed(1)}¬∞</span>
                                                </div>
                                                <div className="flex items-center gap-1 col-span-2">
                                                    <span className="text-slate-500">Color:</span>
                                                    <span className="w-3 h-3 rounded-full border border-slate-600" style={{background: autoStyle.color}}></span>
                                                    <span className="font-medium">{autoStyle.color}</span>
                                                </div>
                                            </div>
                                        </div>

                                        <div className="flex gap-2 pt-4">
                                            <button
                                                onClick={() => setStatus('IDLE')}
                                                className="flex-1 py-2 bg-slate-800 hover:bg-slate-700 rounded text-sm transition">
                                                Cancel
                                            </button>
                                            <button
                                                onClick={apply}
                                                className="flex-1 py-2 bg-blue-600 hover:bg-blue-500 text-white font-medium rounded text-sm transition shadow-lg shadow-blue-900/20">
                                                ‚ú® Apply Magic
                                            </button>
                                        </div>
                                    </div>
                                )}

                                <div className="mt-auto pt-6 border-t border-slate-800 space-y-2">
                                    {history.length > 0 && (
                                        <div className="text-xs text-slate-500 mb-2">
                                            {history.length} edit{history.length > 1 ? 's' : ''} applied
                                        </div>
                                    )}
                                    <button
                                        onClick={() => {
                                            const link=document.createElement('a');
                                            link.download='magic-edited.png';
                                            link.href=canvasRef.current.toDataURL();
                                            link.click();
                                        }}
                                        className="w-full py-2 bg-green-600/10 hover:bg-green-600/20 text-green-400 border border-green-600/30 rounded text-sm transition">
                                        üíæ Download Result
                                    </button>
                                    <button
                                        onClick={() => {
                                            setFile(null);
                                            setHistory([]);
                                            setStatus('IDLE');
                                        }}
                                        className="w-full py-2 bg-slate-800 hover:bg-slate-700 text-slate-400 rounded text-sm transition">
                                        Upload New File
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="flex-1 bg-slate-950 canvas-bg relative overflow-auto flex items-center justify-center p-8">
                        <canvas
                            ref={canvasRef}
                            onMouseDown={onDown}
                            onMouseMove={onMove}
                            onMouseUp={onUp}
                            className={`shadow-2xl ${status === 'IDLE' ? 'cursor-crosshair' : 'cursor-default'}`}
                        />
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
